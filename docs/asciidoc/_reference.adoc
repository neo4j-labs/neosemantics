[[Reference]]
== NSMNTX Reference 

Complete list of all available stored procedures, functions and extensions in NSMNTX.

### Stored Procedures

#### RDF Import

[options="header"]
|===
| Procedure Name        | params           | Description and example usage
|semantics.importRDF
a|
* URL of the dataset
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
|Fetches RDF from a url (file or http) and stores it in Neo4j as a property graph. This procedure requires and index on :Resource(uri)
|semantics.importRDFSnippet
a|
* string containing a valid RDF fragment
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
| Imports an RDF snippet passed as parameter and stores it in Neo4j as a property graph. Requires and index on :Resource(uri)
|semantics.importQuadRDF
a|
* URL of the dataset
* serialization format (valid formats: TriG,N-Quads)
* optional map with params from the table below
| importRDF for RDF Quads
|semantics.importOntology
a|
* URL of the dataset
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the *ontology import* table below
| Imports classes, properties (dataType and Object), hierarchies thereof and domain and range info.
|semantics.streamRDF
a|
* URL of the dataset
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
| Parses RDF and streams each triple as a record with <S,P,O> along with datatype and language tag for Literal values. No writing to the DB. This SP is useful when you want to import into your Neo4j graph fragments of an RDF dataset in a custom way.
|semantics.previewRDF
a|
* URL of the dataset
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
| Parses RDF and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB. Notice that this is adequate for a preliminary visual analysis of a SMALL dataset. Think how many nodes you want rendered in your browser.
|semantics.previewRDFSnippet
a|
* string containing a valid RDF fragment
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
| Parses an RDF fragment passed as parameter (no retrieval from url) and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB
|semantics.deleteRDF
a|
* URL of the dataset
* serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)
* optional map with params from the table below
| Deletes triples from Neo4j. Works on a graph resulted of importing RDF via semantics.importRDF(). Delete config must match the one used on import
|semantics.deleteQuadRDF
a|
 * URL of the dataset
 * serialization format (valid formats: TriG,N-Quads)
 * optional map with params from the table below
| Deletes quads from Neo4j. Works on a graph resulted of importing RDF quads via semantics.importQuadRDF(). Delete config must match the one used on import
|===

##### RDF Import Params


[options="header"]
|===
| Param        | values(default)           | Description
| handleVocabUris      | 'SHORTEN','IGNORE','MAP','KEEP' ('SHORTEN')
a| * 'SHORTEN', full uris are shortened using prefixes for property names, relationship names and labels
* 'IGNORE' uris are ignored and only local names are kept
* 'MAP' vocabulary element mappings are applied on import
* 'KEEP' uris are kept unchanged
| applyNeo4jNaming | boolean (false)| when set to true and in combination with `handleVocabUris: 'IGNORE'`, Neo4j
capitalisation is applied to vocabulary elements (all caps for relationship types, capital first for labels, etc.)
| handleMultival | 'OVERWRITE', 'ARRAY' ('OVERWRITE')
a| * 'OVERWRITE' property values are kept single valued. Multiple values in the imported RDF are overwriten (only the last one is kept)
* 'ARRAY' properties are stored in an array enabling storage of multiple values. All of them unless `multivalPropList` is set.
| multivalPropList | list of strings ([])| List of property names (full uri) to be stored as arrays. The rest are treated as 'OVERWRITE'.
| keepLangTag | boolean (false) | when set to true, the language tag is kept along with the property value. Useful for multilingual datasets.
Use helper function `getLangValue` to get specific values.
| predicateExclusionList | list of strings ([]) | List  of predicates (full uri) that are to be ignored on parsing RDF and not stored in Neo4j.
| typesToLabels      | boolean (true) | when set to true, rdf:type statements are imported as node labels in Neo4j
| languageFilter      | ['en','fr','es',...] | when set, only literal properties with this language tag (or untagged ones) are imported
| headerParams      | map {} | parameters to be passed in the HTTP GET request or `payload` if POST request. <br> Example: `{ authorization: 'Basic user:pwd', Accept: 'application/rdf+xml'}`
| commitSize      | integer (25000) | commit a partial transaction every n triples
| nodeCacheSize      | integer (10000) | keep n nodes in cache to minimize reads from DB
| verifyUriSyntax | boolean (true) | by default, uri syntax is checked. This can be disable d by setting this parameter to `false`
| keepCustomDataTypes | boolean(false) | when set to true, all properties containing a custom data type will be saved as a string followed by their custom data type IRIs
| customDataTypedPropList| list of strings ([]) | when set, only custom data types of literal properties in this list are imported
|===


##### Ontology Import Params


[options="header"]
|===
| Param        | values(default)           | Description
| predicateExclusionList | list of strings ([]) | List  of predicates (full uri) that are to be ignored on parsing RDF and not stored in Neo4j.
| headerParams      | map {} | parameters to be passed in the HTTP GET request or `payload` if POST request. <br> Example: `{ authorization: 'Basic user:pwd', Accept: 'application/rdf+xml'}`
| commitSize      | integer (25000) | commit a partial transaction every n triples
| nodeCacheSize      | integer (10000) | keep n nodes in cache to minimize reads from DB
| verifyUriSyntax | boolean (true) | by default, uri syntax is checked. This can be disable d by setting this parameter to `false`
| classLabelName      | string ('Class') |  Label for classes in the ontology
| subClassOfRelName      | string ('SCO') |  Relationship name for `rdfs:subClassOf` statements
| dataTypePropertyLabelName      | string ('Property') |  Label for DataTypeProperty definitions (attributes)
| objectPropertyLabelName      | string ('Relationship') |  Label for ObjectProperty definitions (relationships)
| subPropertyOfRelName      | string ('SPO') |  Relationship  for `rdfs:subPropertyOf` statements
| domainRelName      | string ('DOMAIN') |  Domain relationship between Classes and DataTypeProperty/ObjectProperty
| rangeRelName      | string ('RANGE') |  Range relationship between Classes and DataTypeProperty/ObjectProperty
|===


#### RDF Import Utils

[options="header"]
|===
| Procedure Name        | params           | Description and example usage
|semantics.addNamespacePrefix
a|
* prefix: string (like `owl`)
* namespace: namespace part of a uri (like `http://www.w3.org/2002/07/owl#`)
| Adds namespace - prefix pair definition to be used for RDF import
|semantics.listNamespacePrefixes | params | Lists all currently defined namespace prefix definitions
|===


#### Model Mapping

[options="header"]
|===
| Procedure Name        | params           | Description and example usage
| semantics.mapping.addSchema
a| * URL of the schema/vocabulary/ontology
* prefix to be used in serialisations | Creates a reference to a vocabulary. Needed to define mappings.
| semantics.mapping.dropSchema
a|
* URL of the schema/vocabulary/ontology| Deletes a vocabulary reference and all associated mappings.
| semantics.mapping.listSchemas
a| * optional filter string |  Returns all vocabulary references. When filter string is set, only schemas containing the search string in their uri or in the associated prefix are returned.
| semantics.mapping.addCommonSchemas      | no prams | Creates references to a number of popular vocabularies including schema.org, Dublin Core, SKOS, OWL, etc
| semantics.mapping.addMappingToSchema
a| * URL of the schema/voc/ontology
* The name of the element in the Neo4j graph (a property name, a label or a relationship type)
* The matching element (Class, DataTypeProperty or ObjectProperty) in the public schema. Only the local name of the element |
Creates a mapping for an element in the Neo4j DB schema to a vocabulary element
| semantics.mapping.dropMapping      |
* mapped DB element name to remove the mapping |
Returns an output text message indicating success/failure of the deletion
| semantics.mapping.listMappings
a|
* optional filter string
| Returns a list with all the currently defined mappings. Whe filter string is passed, only mappings containing the string in the
DB element name or the schema element URI are returned
|===


### Utility Functions
[options="header"]
|===
| Stored Proc Name        | params           | Description and example usage    
| semantics.getIRILocalName      | URI string | Returns the local part of the URI (stripping out the namespace)
| semantics.getIRINamespace      | URI string | Returns the namespace part of the URI (stripping out the local part)
| semantics.getDataType | string (a property value) | Returns the XMLSchema (or custom) datatype of a property value when present
| semantics.getLangValue | string (a property value) | Returns the value with the language tag passed as first argument or null if there's not a value for the provided language tag
| semantics.getValue | string (a property value)| Returns the value of a datatype of a property after stripping out the datatype information or language tag  when present
| semantics.shortFromUri | string (a URI)| Returns the shortened version of an IRI using the existing namespace definitions
| semantics.uriFromShort | string (a shortened URI)| Returns the expanded (full) URI given a shortened one created in the load process with `semantics.importRDF`
|===


#### Inferencing
"semantics.importJSONAsTree"	"semantics.importJSONAsTree(containerNode :: NODE?, jsonpayload :: STRING?, connectingRel = _jsonTree :: STRING?) :: (node :: NODE?)"	"Imports a json payload and maps it to nodes and relationships (JSON-LD style). Requires a uniqueness constraint on :Resource(uri)"	["editor", "publisher", "architect", "admin"]	"WRITE"
"semantics.inference.getRels"	"semantics.inference.getRels(node :: NODE?, rel :: STRING?, params = {} :: MAP?) :: (rel :: RELATIONSHIP?, node :: NODE?)"	"semantics.inference.getRels(node,'rel','>') - returns all relationships of type 'virtRel' or its subtypes along with the target nodes."	["reader", "editor", "publisher", "architect", "admin"]	"READ"
"semantics.inference.nodesInCategory"	"semantics.inference.nodesInCategory(category :: NODE?, params = {} :: MAP?) :: (node :: NODE?)"	"semantics.inference.nodesInCategory('category') - returns all nodes connected to Node 'catNode' or its subcategories."	["reader", "editor", "publisher", "architect", "admin"]	"READ"
"semantics.inference.nodesLabelled"	"semantics.inference.nodesLabelled(label :: STRING?, params = {} :: MAP?) :: (node :: NODE?)"	"semantics.inference.nodesLabelled('label') - returns all nodes with label 'label' or its sublabels."	["reader", "editor", "publisher", "architect", "admin"]	"READ"

"semantics.inference.hasLabel"	"semantics.inference.hasLabel(node :: NODE?, label :: STRING?, params = {} :: MAP?) :: (BOOLEAN?)"	"semantics.inference.hasLabel(node,label,{}) - checks whether node is explicitly or implicitly labeled as 'label'."	["admin", "reader", "editor", "publisher", "architect"]
"semantics.inference.inCategory"	"semantics.inference.inCategory(node :: NODE?, category :: NODE?, params = {} :: MAP?) :: (BOOLEAN?)"	"semantics.inference.inCategory(node, category, {}) - checks whether node is explicitly or implicitly in a category."	["admin", "reader", "editor", "publisher", "architect"]




### Extensions (HTTP endpoints)
[options="header"]
[cols="15,5,45,35"]
|===
| method| type| params| Description
| /rdf/describe/id/<nodeid>
|GET
a|
* nodeid: path parameter containing the id of a node
* excludeContext: Optional named parameter. If present output will not include connected nodes, just selected one.
* format: RDF serialisation format. When present, it overrides the header param *accept*.
| Produces an RDF serialization of the selected node. The format will be determined by the *accept* parameter in the header. Default is Turtle
| /rdf/describe/uri/<nodeuri>
|GET
a|
* nodeuri: path parameter containing the (urlencoded) uri of a node.
* excludeContext: (optional) if present output will not include connected nodes, just selected one.
* graphuri: (optional) if present and the graph includes Quad information, only statements in the selected named graph are returned.The value  of the parameter is the (urlencoded) uri of a named graph.
* format: RDF serialisation format. When present, it overrides the header param *accept*.
| Produces an RDF serialization of the selected node. It works on a model either imported from an RDF dataset
via **semantics.importRDF**, **semantics.importQuadRDF** or built in a way that nodes are labeled as :Resource and have an uri.
|/rdf/describe/find/<l>/<p>/<v>
|GET
a|
* the method takes three parameters passed as path parameters in the URL: <l>/<p>/<v>. They represent respectively a label, a property name and a property value.
* excludeContext: Optional named parameter. If present output will not include connected nodes, just selected one.
* valType: required when the property value is not to be treated as a string. Valid values: INTEGER, FLOAT and BOOLEAN
* format: RDF serialisation format. When present, it overrides the header param *accept*.
| returns  nodes matching the filter on label and property value
| /rdf/cypher
| POST
a| POST request taking as parameter a JSON map with the following keys:

* cypher: the cypher query to run
* cypherParams: parameters  for the cypher query
* showOnlyMapped: (optional, default is false) if present output will exclude unmapped elements (see how to define mappings for labels,attributes, relationships)
* format: RDF serialisation format. When present, it overrides the header param *accept*.
| Produces an RDF serialization of the nodes and relationships returned by the Cypher query
| /rdf/cypheronrdf
| POST
a| same parameters as `/rdf/cypher`
| Same as `/rdf/cypher` but it works on a model either imported from an RDF dataset via **semantics.importRDF** or built in a
way that nodes are labeled as :Resource and have an uri.
|/rdf/onto
| GET
a| * format: RDF serialisation format. When present, it overrides the header param *accept*.
| returns an OWL ontology based on the graph schema
|/rdf/ontonrdf
| GET
a| * format: RDF serialisation format. When present, it overrides the header param *accept*.
| Same as  /rdf/onto but it works on a model either imported from an RDF dataset via **semantics.importRDF** or built in a
way that nodes are labeled as :Resource and have an uri.
|===
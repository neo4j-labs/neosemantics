<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>NSMNTX User Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>NSMNTX User Guide</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#Install">Installation</a>
<ul class="sectlevel2">
<li><a href="#_feedback">Feedback</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a></li>
</ul>
</li>
<li><a href="#Import">Importing RDF data</a>
<ul class="sectlevel2">
<li><a href="#_filtering_triples_by_predicate">Filtering triples by predicate</a></li>
<li><a href="#_handling_multivalued_properties">Handling multivalued properties</a></li>
<li><a href="#_handling_language_tags">Handling language tags</a></li>
<li><a href="#_filtering_triples_by_language_tag">Filtering triples by language tag</a></li>
<li><a href="#_handling_custom_data_types">Handling custom data types</a></li>
<li><a href="#_classess_as_nodes_instead_of_labels">Classess as Nodes (instead of Labels)</a></li>
<li><a href="#ImportQuadRDF">Handling named graphs (RDF Quads)</a></li>
<li><a href="#advancedfetching">Advanced settings for fetching RDF</a></li>
<li><a href="#custom_ns">Defining custom prefixes for namespaces</a></li>
</ul>
</li>
<li><a href="#DeleteRDF">Deleting RDF</a>
<ul class="sectlevel2">
<li><a href="#_handling_named_graphs_rdf_quads">Handling named graphs (RDF Quads)</a></li>
</ul>
</li>
<li><a href="#OntoImport">Importing Ontologies</a></li>
<li><a href="#Preview">Previewing RDF data</a>
<ul class="sectlevel2">
<li><a href="#_streaming_triples">Streaming triples</a></li>
<li><a href="#_previewing_rdf_data">Previewing RDF data</a></li>
</ul>
</li>
<li><a href="#Export">Exporting RDF data</a>
<ul class="sectlevel2">
<li><a href="#_by_node_id">By node ID</a></li>
<li><a href="#_by_uri">By URI</a></li>
<li><a href="#_by_label_property_value">By Label + property value</a></li>
<li><a href="#_using_cypher">Using Cypher</a></li>
<li><a href="#_export_graph_ontology">Export Graph Ontology</a></li>
</ul>
</li>
<li><a href="#Mapping">Mapping graph models</a>
<ul class="sectlevel2">
<li><a href="#_public_vocabularies_ontologies">Public Vocabularies/Ontologies</a></li>
<li><a href="#_defining_mappings">Defining mappings</a></li>
<li><a href="#_mappings_for_export">Mappings for export</a></li>
<li><a href="#_mappings_for_import">Mappings for import</a></li>
</ul>
</li>
<li><a href="#Inference">Inferencing/Reasoning</a>
<ul class="sectlevel2">
<li><a href="#_hierarchies_of_categories">Hierarchies of Categories</a></li>
<li><a href="#_hierarchies_of_relationships">Hierarchies of Relationships</a></li>
</ul>
</li>
<li><a href="#Reference">NSMNTX Reference</a>
<ul class="sectlevel2">
<li><a href="#_stored_procedures">Stored Procedures</a></li>
<li><a href="#_utility_functions">Utility Functions</a></li>
<li><a href="#_extensions_http_endpoints">Extensions (HTTP endpoints)</a></li>
</ul>
</li>
<li><a href="#Examples">Projects using NSMNTX</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="introduction" class="imageblock" style="text-align: center;float: right">
<div class="content">
<img src="docs/img/nsmntx-block-diagram.png" alt="NSMNTX diagram" width="200">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="link" href="#_introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>NSMNTX is a plugin that enables the <strong>use of RDF in Neo4j</strong>. <a href="https://www.w3.org/RDF/">RDF is a W3C standard model</a> for data interchange.
This effectively means that NSMNTX makes it possible to</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Store RDF data in Neo4j</strong> in a
lossless manner (imported RDF can subsequently be exported without losing a single triple in the process).</p>
</li>
<li>
<p>On-demand <strong>export property graph data</strong> from Neo4j <strong>as RDF</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other features in NSMNTX include <strong>model mapping</strong> and <strong>inferencing</strong> on Neo4j graphs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Install"><a class="link" href="#Install">Installation</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can either download a prebuilt jar from the <a href="https://github.com/jbarrasa/neosemantics/releases">releases area</a> or build it from the source. If you prefer to build, check the note below.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the  the jar(s) in the &lt;NEO_HOME&gt;/plugins directory of your Neo4j instance. (<strong>note:</strong> If you&#8217;re going to use the JSON-LD serialisation format for RDF, you&#8217;ll need to include also <a href="https://neo4j-contrib.github.io/neo4j-apoc-procedures/">APOC</a>)</p>
</li>
<li>
<p>Add the following line to your &lt;NEO_HOME&gt;/conf/neo4j.conf (notice that it is possible to modify where the extension is mounted by using an alternative name to <code>/rdf</code> below).</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>server.unmanaged_extension_classes=n10s.extension=/rdf</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Restart the server.</p>
</li>
<li>
<p>Check that the installation went well by running</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">call dbms.procedures()</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The list of procedures should include the ones documented below.
You can check that the extension is mounted by running</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">:GET /rdf/ping</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note on build</strong></p>
</div>
<div class="paragraph">
<p>When you run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">  mvn clean package</code></pre>
</div>
</div>
<div class="paragraph">
<p>it will produce two jars</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A neosemantics-[&#8230;&#8203;].jar This jar bundles all the dependencies.</p>
</li>
<li>
<p>An original-neosemantics-[&#8230;&#8203;].jar This jar is just the neosemantics bit. So go this way if you want to keep the third party jars separate. In this case you will have to add all third party dependencies (look at the pom.xml).</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_feedback"><a class="link" href="#_feedback">Feedback</a></h3>
<div class="paragraph">
<p>Please provide feedback and report bugs as <a href="https://github.com/jbarrasa/neosemantics/issues">GitHub issues</a> or join the <a href="https://community.neo4j.com/">Neo4j Community</a> forum.</p>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgements"><a class="link" href="#_acknowledgements">Acknowledgements</a></h3>
<div class="paragraph">
<p>NSMNTX uses <a href="https://rdf4j.eclipse.org/">rdf4j</a> for parsing and serialising RDF. Eclipse rdf4j is a powerful Java framework for processing and handling RDF data.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Import"><a class="link" href="#Import">Importing RDF data</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main method for importing RDF is <code>n10s.importRDF</code>. It imports and persists into Neo4j the triples returned by an url. This url can point to an RDF file (local or remote) or a service producing RDF dynamically. More on how to parameterise the access to web services in section x[link].</p>
</div>
<div class="paragraph">
<p>All import procedures take the following three parameters:</p>
</div>
<table id="common_params" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL of the dataset</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">format</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">serialization format. Valid formats are: Turtle, N-Triples, JSON-LD, RDF/XML, <strong>TriG and N-Quads</strong> (For named graphs)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">params</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional set of parameters (see description in table below)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Note</strong> that for this method to run, an index needs to exist on property <code>uri</code> of nodes labeled as <code>Resource</code> so if you have not done it, just run the following command on your DB or the <code>n10s.importRDF</code> procedure will remind you with an error messsage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CREATE INDEX ON :Resource(uri)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In its most basic form the <code>n10s.importRDF</code> method just takes the url string to access the RDF data and the serialisation format. Let&#8217;s say you&#8217;re trying to load the following set of triples into Neo4j.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix neo4voc: &lt;http://neo4j.org/vocab/sw#&gt; .
@prefix neo4ind: &lt;http://neo4j.org/ind#&gt; .

neo4ind:nsmntx3502 neo4voc:name "NSMNTX" ;
         a neo4voc:Neo4jPlugin ;
         neo4voc:version "3.5.0.2" ;
         neo4voc:releaseDate "03-06-2019" ;
         neo4voc:runsOn neo4ind:neo4j355 .

neo4ind:apoc3502 neo4voc:name "APOC" ;
         a neo4voc:Neo4jPlugin ;
         neo4voc:version "3.5.0.4" ;
         neo4voc:releaseDate "05-31-2019" ;
         neo4voc:runsOn neo4ind:neo4j355 .

neo4ind:graphql3502 neo4voc:name "Neo4j-GraphQL" ;
         a neo4voc:Neo4jPlugin ;
         neo4voc:version "3.5.0.3" ;
         neo4voc:releaseDate "05-05-2019" ;
         neo4voc:runsOn neo4ind:neo4j355 .

neo4ind:neo4j355 neo4voc:name "neo4j" ;
         a neo4voc:GraphPlatform , neo4voc:AwesomePlatform ;
         neo4voc:version "3.5.5" .</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can save them to your local drive or access them directly <a href="https://raw.githubusercontent.com/jbarrasa/neosemantics/3.5/docs/rdf/nsmntx.ttl">here</a>. All you&#8217;ll need to provide to NSMNTX is the location (<code>file://</code> or <code>http://</code>) and the serialisation used, <code>Turtle</code> in this case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("https://raw.githubusercontent.com/jbarrasa/neosemantics/3.5/docs/rdf/nsmntx.ttl","Turtle")</code></pre>
</div>
</div>
<div class="paragraph">
<p>NSMNTX will import the RDF data and persist it into your Neo4j graph as the following structure</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/nsmntx-annotated.png" alt="RDF data imported in Neo4j">
</div>
</div>
<div class="paragraph">
<p>The first thing we notice is that dataType properties in your RDF have been converted into node properties and object properties are now relationships connecting nodes. Every node represents a resource and has a property with its uri. Similarly, rdf:type statements are transformed into node labels. That&#8217;s pretty much it but if you are interested, there is a complete description of the way triple data is transformed into Property Graph data for storage in Neo4j in <a href="https://jesusbarrasa.wordpress.com/2016/06/07/importing-rdf-data-into-neo4j/">this post</a>.
You will also notice a terminology/vocabulary transformation applied by default. The URIs identifying the elments in the RDF data (resources, properties, etc) have their namespace part shortened to make them more human readable and easier to query with Cypher.</p>
</div>
<div class="paragraph">
<p>In our example, <code><a href="http://neo4j.org/vocab/sw#name" class="bare">http://neo4j.org/vocab/sw#name</a></code> has been shortened to <code>ns0_\_name</code> (notice the double underscore separator used between the prefix and teh local name in the URI). Similarly, <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type" class="bare">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code> would be shortened to <code>rdf\_\_type</code> and so on&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Prefixes for custom namespaces are assigned sequentially (<code>ns0</code>, <code>ns1</code>, etc) as they appear in the imported RDF. This is the default behavior but we&#8217;ll see later on that it is possible to control that, and use custom prefixes. More details in section <a href="#custom_ns">Defining custom prefixes for namespaces</a>.</p>
</div>
<div class="paragraph">
<p>Keeping namespaces can be important if you care about being able to regenerate the imported RDF as we will see in section <a href="#Export">Exporting RDF data</a>. If you don&#8217;t care about that, you can ignore the namespaces by setting the <code>handleVocabUris</code> parameter to <code>'IGNORE'</code> and namespaces will be lost on import. If you run the import with this setting only the local names of URIs will be kept. Here&#8217;s what that would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://.../nsmntx.ttl","Turtle", { handleVocabUris: "IGNORE" })</code></pre>
</div>
</div>
<div class="paragraph">
<p>The imported graph will look something like the following one, in which the names for labels, properties and relationships are more of the kind you&#8217;re use to work with in Neo4j:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/nsmntx-ignore-annotated.png" alt="RDF data imported in Neo4j ignoring namespaces">
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The first great thing about getting your RDF data into Neo4j is that now you can query it with Cypher
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s an example that showcases the difference: Let&#8217;s say you want to produce a <em>list of plugins that run on Neo4j and what&#8217;s the latest versions of each</em>.</p>
</div>
<div class="paragraph">
<p>If your RDF data is stored in a triple store, you would need to use the SPARQL query on the left to answer the question. To the right you can see the same thing expressed with Cypher in Neo4j.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SPARQL</th>
<th class="tableblock halign-left valign-top">Cypher</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sparql" data-lang="sparql">prefix neovoc: &lt;http://neo4j.org/vocab/sw#&gt;
prefix neoind: &lt;http://neo4j.org/ind#&gt;
prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

SELECT ?pluginName
       (MAX(?ver) as ?latestVersion)
WHERE {

	?plugin rdf:type neovoc:Neo4jPlugin ;
		    neovoc:runsOn ?neosrv ;
		    neovoc:name ?pluginName ;
		    neovoc:version ?ver .

	?neosrv rdf:type neovoc:GraphPlatform ;
			neovoc:name "neo4j"
}
GROUP BY ?pluginName</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:Neo4jPlugin)-[:runsOn]-&gt;(p:GraphPlatform)
WHERE p.name = "neo4j"
RETURN n.name, MAX(n.version)</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We&#8217;ve seen how to shorten RDF uris into more readable names using namespace prefixes, and we&#8217;ve also seen how to ignore them completely. There is a third option: You can keep the complete uris in property names, labels and relationships in the graph by setting the <code>handleVocabUris</code> property to <code>"KEEP"</code>. The result will not be pretty and your cypher queries will be horrible, but hey, the option is there. Here&#8217;s an example on the same RDF file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://.../nsmntx.ttl","Turtle", { handleVocabUris: "KEEP" })</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/nsmntx-keep-annotated.png" alt="RDF data imported in Neo4j keeping namespaces">
</div>
</div>
<div class="paragraph">
<p>The imported graph in this case has the same structure, of course, but uses full uris as labels, relationships an property names.</p>
</div>
<div class="sect2">
<h3 id="_filtering_triples_by_predicate"><a class="link" href="#_filtering_triples_by_predicate">Filtering triples by predicate</a></h3>
<div class="paragraph">
<p>Something you may need to do when importing RDF data into Neo4j is exclude certain triples so that they are not persisted in your Neo4j graph. This is useful when only a portion of the RDF data is relevant to your projecty. The exclusion is done by predicate type <em>"I don&#8217;t need to load the version property, or the release date"</em>, all you&#8217;ll need to do is provide the list of URIs of the predicates you want excluded in parameter <code>predicateExclList</code>. Note that the list needs to contain full URIs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/nsmntx.ttl","Turtle", { handleVocabUris: "IGNORE" , predicateExclusionList : [ "http://neo4j.org/vocab/sw#version", "http://neo4j.org/vocab/sw#releaseDate"] })</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_multivalued_properties"><a class="link" href="#_handling_multivalued_properties">Handling multivalued properties</a></h3>
<div class="paragraph">
<p>In RDF multiple values for the same property are just multiple triples. For example, you can have multiple alternative names for an individual like in the next RDF fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">&lt;neo4j://individual/JB&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://neo4j.org/voc#Person&gt; .
&lt;neo4j://individual/JB&gt; &lt;http://neo4j.org/voc#name&gt; "J. Barrasa" .
&lt;neo4j://individual/JB&gt; &lt;http://neo4j.org/voc#altName&gt; "JB" .
&lt;neo4j://individual/JB&gt; &lt;http://neo4j.org/voc#altName&gt; "Jesús" .
&lt;neo4j://individual/JB&gt; &lt;http://neo4j.org/voc#altName&gt; "Dr J" .</code></pre>
</div>
</div>
<div class="paragraph">
<p>NSMNTX default behavior is to keep only one value for literal properties and it will be the last one read in the triples parsed. So if you run a straight import on that data like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/multivalued1.nt","N-Triples")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only the last value for the multivalued <code>altName</code> property will be kept.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:ns0__Person)
RETURN n.ns0__name as name, n.ns0__altName as altName</code></pre>
</div>
</div>
<div class="paragraph">
<p>returns</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒════════════╤═════════╕
│"name"      │"altName"│
╞════════════╪═════════╡
│"J. Barrasa"│"Dr J"   │
└────────────┴─────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes things simple and will be perfect if your dataset does not have multivalued properties. It can also be fine if keeping only one value is acceptable, either because the property is not critical or because one value is enough. There will be other cases though, where we do need to keep all the values, and here&#8217;s where the config parameter <code>handleMultival</code> will help. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/multivalued1.nt","N-Triples", { handleMultival: 'ARRAY' })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now all properties are stored as arrays in Neo4j. Even the ones that have one value only! But we can do better than that, let&#8217;s have a look at another example.</p>
</div>
<div class="paragraph">
<p>The following Turtle RDF fragment with the description of a news article. The article has a number of keykeywords associated with it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix og: &lt;http://ogp.me/ns#&gt; .
@prefix nyt: &lt;http://nyt.com/voc/&gt; .

&lt;nyt://article/a17a9514-73e7-51be-8ade-283e84a6cd87&gt;
  a og:article ;
  og:title "Bengal Tigers May Not Survive Climate Change" ;
  og:url "https://www.nytimes.com/2019/05/06/science/tigers-climate-change-sundarbans.html" ;
  og:description "The tigers of the Sundarbans may be gone in fifty years, according to study" ;
  nyt:keyword "Climate Change", "Endangered Species", "Global Warming", "India", "Poaching" .</code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to make sure we keep all values for the <code>nyt:keyword</code> property. The natural way to do this in Neo4j is storing them in an array, so we&#8217;ll instruct NSMNTX to do that by setting the <code>handleMultival</code> to <code>'ARRAY'</code> and the <code>multivalPropList</code> to the list of property types that are multivalued and we want stored as arrays of values. In the example the list will only contain <code>'http://nyt.com/voc/keyword'</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s teh import command that we need. Note that I&#8217;m combining the multivalued property config setting with the <code>handleVocabUris</code> set to false (the interested reader can try to drop this config and get URIS shortened with prefixes instead):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/multivalued2.ttl","Turtle", { handleVocabUris: "IGNORE", handleMultival: 'ARRAY', multivalPropList : ['http://nyt.com/voc/keyword']})</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s what the result of the import would look like:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/multivalued1.png" alt="Multivalued properties loaded as arrays in Neo4j">
</div>
</div>
<div class="paragraph">
<p>When we analyse the result in the Neo4j browser we realise that there&#8217;s only one node for the nine triples imported! Yes, keep in mind that all triples in our RDF fragment are datatype properties, or in other words, properties with literal values, which are stored in Neo4j as node properties. All the statements are there, <strong>no data is lost</strong>, it&#8217;s just stored as the internal structure of the node. We can see all properties on the table view on the left hand side of the image.</p>
</div>
<div class="paragraph">
<p>Note that this time only the properties listed in the <code>multivalPropList</code> config parameter are stored as arrays, the rest are kept as atomic values.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Remember that if we set <code>handleMultival</code> to <code>'ARRAY'</code> but we don&#8217;t provide a list of property URIs as <code>multivalPropList</code> ALL literal properties will be stored as arrays.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of how to query the multiple values of the keyword property:  <em>Give me articles tagged with the "Global Warming" keyword</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (a:article)
WHERE "Global Warming" IN a.keyword
RETURN a.title as title</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════════════════════════════════════╕
│"title"                                       │
╞══════════════════════════════════════════════╡
│"Bengal Tigers May Not Survive Climate Change"│
└──────────────────────────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_language_tags"><a class="link" href="#_handling_language_tags">Handling language tags</a></h3>
<div class="paragraph">
<p>Literal values in RDF can be tagged with language information. This can be used in any context but it&#8217;s common to find it used in combination with multivalued properties to create multilingual descriptions for items in a dataset. In the following example we have a description of a TV series with a multivalued property <code>show:localName</code> where each of the values is annotated with the language.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix show: &lt;http://example.org/vocab/show/&gt; .
@prefix indiv: &lt;http://example.org/ind/&gt; .

ind:218 a show:TVSeries
ind:218 show:name "That Seventies Show" .
ind:218 show:localName "That Seventies Show"@en .
ind:218 show:localName 'Cette Série des Années Soixante-dix'@fr .
ind:218 show:localName "Cette Série des Années Septante"@fr-be .</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, NSMNTX will strip out the language tags but if you want to keep them you&#8217;ll need to set the <code>keepLangTag</code> to <code>true</code>. If we uset it in combination with the setting required to keep all values of a property stored in an array, the import invocation would look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/multilang.ttl","Turtle", { keepLangTag: true, handleMultival: 'ARRAY', multivalPropList : ['http://example.org/vocab/show/localName']})</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you import literal values keeping the language annotation, you&#8217;ll see that string values have a suffix like <code>@fr</code> for French language, <code>@zh-cmn-Hant</code> for Mandarin Chinese traditional, and so on.
The function <code>getLangValue</code> can be used to get the value for a particular language tag. It returns null when there is not a value for the selected language tag.
The following Cypher fragment returns the french version of a property and when not found, defaults to the english version.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:Resource) RETURN coalesce(n10s.getLangValue("fr",n.ns0__localName), n10s.getLangValue("en",n.ns0__localName))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filtering_triples_by_language_tag"><a class="link" href="#_filtering_triples_by_language_tag">Filtering triples by language tag</a></h3>
<div class="paragraph">
<p>Language tags can also be used as a filter criteria. If we are only interested in a particular language when loading a multilingual dataset, we can set a filter so only literal values with a given language tag (or untagged ones) are imported into Neo4j. The configuration parameter that does it is <code>languageFilter</code> and you&#8217;ll need to set it to the relevant tag, for instance 'es' for literals in Spanish language. Here&#8217;s what such a configuration would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/multilang.ttl","Turtle", { languageFilter: 'es'})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_custom_data_types"><a class="link" href="#_handling_custom_data_types">Handling custom data types</a></h3>
<div class="paragraph">
<p>In RDF custom data types are annotated to literals after the seperator <code>^^</code> in form of an IRI.
For example, you can have a custom data type for a currency like in the following Turtle RDF fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://example.com/&gt; .

ex:Mercedes
	rdf:type ex:Car ;
	ex:price "10000"^^ex:EUR ;
	ex:power "300"^^ex:HP ;
	ex:color "red"^^ex:Color .</code></pre>
</div>
</div>
<div class="paragraph">
<p>NSMNTX default behavior is to not keep custom data types for properties.
So if you run a straight import on that data like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/customDataTypes.ttl","Turtle")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only the value for the properties will be kept.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:ns0__Car)
RETURN n.ns0__price, n.ns0__power, n.ns0__color</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════╤══════════════╤══════════════╕
│"n.ns0__price"│"n.ns0__power"│"n.ns0__color"│
╞══════════════╪══════════════╪══════════════╡
│"10000"       │"300"         │"red"         │
└──────────────┴──────────────┴──────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes things simple and will be perfect if your dataset does not have properties with custom data types.
But if you need to keep the custom data types the config parameter <code>keepCustomDataTypes</code> comes into play. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/customDataTypes.ttl","Turtle", {keepCustomDataTypes: true})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now all properties that have a custom data type are saved as strings with their respective custom data type IRIs in Neo4j.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒═════════════════╤══════════════╤═════════════════╕
│"n.ns0__price"   │"n.ns0__power"│"n.ns0__color"   │
╞═════════════════╪══════════════╪═════════════════╡
│"10000^^ns0__EUR"│"300^^ns0__HP"│"red^^ns0__Color"│
└─────────────────┴──────────────┴─────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>But we can do better than that, let&#8217;s have a look at another example.We will use the same Turtle file from above for this example.</p>
</div>
<div class="paragraph">
<p>If we want to keep the custom data type for only some of the properties then we can instruct NSMNTX to do that by setting <code>keepCustomDataTypes</code> to <code>true</code> and <code>customDataTypedPropList</code> to the list of property types whose custom data types we want to keep.
In the example the list will only contain <code>'http://example.com/power'</code>.</p>
</div>
<div class="paragraph">
<p>Here is the import command that we need:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/customDataTypes.ttl","Turtle", {keepCustomDataTypes: true, customDataTypedPropList: ['http://example.com/power']})</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s what the result of the cypher query above would look like after this import:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════╤══════════════╤══════════════╕
│"n.ns0__price"│"n.ns0__power"│"n.ns0__color"│
╞══════════════╪══════════════╪══════════════╡
│"10000"       │"300^^ns0__HP"│"red"         │
└──────────────┴──────────────┴──────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this time only the custom data types of the properties listed in the <code>customDataTypedPropList</code> are kept, the rest will only have the literal value.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Remember that if we set <code>keepCustomDataTypes</code> to <code>true</code> but we don&#8217;t provide a list of property URIs as <code>customDataTypedPropList</code> ALL literals with a custom data type will be stored as strings with their respective custom data type IRIs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you import literal values keeping the custom data types, you&#8217;ll see that string values have a IRI suffix separated by <code>^^</code> from the raw value. For instance <code>"10000^^ns0__EUR"</code> from the example above.
The function <code>getDataType</code> can be used to get the data type for a particular property. It returns null when there is no custom data type for the given property.</p>
</div>
<div class="paragraph">
<p>The following Cypher fragment returns the data type of <code>power</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:ns0__Car)
RETURN n10s.getDataType(n.ns0__power)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>getValue</code> can be used to get the raw value of a particular property without custom data types or language tags.</p>
</div>
<div class="paragraph">
<p>The following Cypher fragment returns the raw value of <code>power</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (n:ns0__Car)
RETURN n10s.getValue(n.ns0__power)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The user functions mentioned above can be combined with other user functions like <code>uriFromShort</code> or <code>getIRILocalName</code> etc.</p>
</div>
</div>
<div class="sect2">
<h3 id="_classess_as_nodes_instead_of_labels"><a class="link" href="#_classess_as_nodes_instead_of_labels">Classess as Nodes (instead of Labels)</a></h3>
<div class="paragraph">
<p>The rdf:type statements in RDF (triples) are transformed into labels by default when we import them into Neo4j. While this is a reasonable approach it may not be your preferred option, especially if you want to load an ontology too and link it to your instance data. In that case you&#8217;ll probably want to represent the types as nodes and have 'the magic' of uris have them linked. Be careful if you try this approach when loading large datasets as it can create very dense nodes.
If you want <code>rdf:type</code> statements (triples) to be imported in this way, all you have to do is set the <code>typesToLabels</code> parameter to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example: Let&#8217;s say we want to load an ontology (notice that it&#8217;s actually a small fragment of several ontologies, but it will work for our example). For what it&#8217;s worth, it&#8217;s an RDF file, so we load it the usual way, with all default settings</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">call n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/minionto.ttl","Turtle")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can inspect the result of the import to see that the ontology contains just five class definitions linked in a hierarchy like this.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/minionto.png" alt="Ontology imported in Neo4j">
</div>
</div>
<div class="paragraph">
<p>Now we want to load the instance data and we want it to link to the ontology graph rather than build a disconnected graph by transforming <code>rdf:type</code> statements into Property Graph labels. We can achieve this by setting the <code>typesToLabels</code> to <code>false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">call n10s.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/miniinstances.ttl","Turtle", { typesToLabels: false })</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting graph connects the instance data to the ontology elements. This is the magic of unique identifiers (uris), tere&#8217;s nothing you need to do for the linkage to happen, if your RDF is well formed and uris are used consistently in it, then it will happen automatically.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/miniontoandinstances.png" alt="Connected ontology and instance data imported in Neo4j">
</div>
</div>
<div class="paragraph">
<p>More on the usefulness of representing the ontology in the neo4j graph in section <a href="#Inference">Inferencing/Reasoning</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ImportQuadRDF"><a class="link" href="#ImportQuadRDF">Handling named graphs (RDF Quads)</a></h3>
<div class="paragraph">
<p>You can also import RDF datasets using <code>n10s.importQuadRDF</code>. The only difference in comparison to <code>n10s.importRDF</code> is that you can import not just triples but also quads. RDF statements can have an extra IRI containing the context of the statement. It enables the partitioning of the data into multiple so called named graphs. When a statement has context information NSMNTX annotates Resources from this statement with a property "graphUri". This property contains the context IRI from the statement.</p>
</div>
<div class="paragraph">
<p>Note that you need to use TriG or N-Quads serializations if you want to take advantage of the named graph function.</p>
</div>
<div class="paragraph">
<p>Similar to <code>n10s.importRDF</code> method <code>n10s.importQuadRDF</code> also takes the url string to access the RDF dataset and the serialisation format.
Let&#8217;s say you&#8217;re trying to load the following set of quads into Neo4j.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://www.example.org/vocabulary#&gt; .
@prefix exDoc: &lt;http://www.example.org/exampleDocument#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

exDoc:G1 ex:created "2019-06-06"^^xsd:date .
exDoc:G2 ex:created "2019-06-07T10:15:30"^^xsd:dateTime .

exDoc:Monica a ex:Person ;
             ex:friendOf exDoc:John .

exDoc:G1 {
    exDoc:Monica
              ex:name "Monica Murphy" ;
              ex:homepage &lt;http://www.monicamurphy.org&gt; ;
              ex:email &lt;mailto:monica@monicamurphy.org&gt; ;
              ex:hasSkill ex:Management ,
                                  ex:Programming .
    exDoc:Monica ex:knows exDoc:John . }

exDoc:G2 {
    exDoc:Monica
              ex:city "New York" ;
              ex:country "USA" . }


exDoc:G3 {
    exDoc:John a ex:Person . }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong> that for this method to run, an index needs to exist on property <code>uri</code> of nodes labeled as <code>Resource</code> so if you have not done it, just run the following command on your DB or the <code>n10s.importQuadRDF</code> procedure will remind you with an error messsage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CREATE INDEX ON :Resource(uri)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This procedure takes the same generic params described in <a href="#common_params">[common_params]</a> at the beginning of the <a href="#Import">Importing RDF data</a> section, so we will invoke it with a URL and a serialisation format. In the following example we will import the RDF dataset in <a href="docs/rdf/RDFDataset/RDFDataset.trig">this file</a>.</p>
</div>
<div class="paragraph">
<p>You can use the following cypher snippet to import the set of quads from above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importQuadRDF( "file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/RDFDataset/RDFDataset.trig", "TriG", {typesToLabels: true, keepCustomDataTypes: true, handleMultival: 'ARRAY'})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_merging_nodes_virtually"><a class="link" href="#_merging_nodes_virtually">Merging nodes virtually</a></h4>
<div class="paragraph">
<p>While importing the RDF dataset above NSMNTX will create a separate node for each instance of <code>exDoc:Monica</code>. That means you will have three nodes each representing a different graph. This might complicate things when you want to for example query everything about <code>exDoc:Monica</code> with the following cypher snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (monica:Resource {uri: 'http://www.example.org/exampleDocument#Monica'})
RETURN monica</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result you will get three distinct nodes, which look like this in text mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════════════════════════════════════════════════════════════╕
│"monica"                                                              │
╞══════════════════════════════════════════════════════════════════════╡
│{"http://www.example.org/vocabulary#name":["Monica Murphy"],"uri":"htt│
│p://www.example.org/exampleDocument#Monica","graphUri":"http://www.exa│
│mple.org/exampleDocument#G1"}                                         │
├──────────────────────────────────────────────────────────────────────┤
│{"http://www.example.org/vocabulary#city":["New York"],"http://www.exa│
│mple.org/vocabulary#country":["USA"],"uri":"http://www.example.org/exa│
│mpleDocument#Monica","graphUri":"http://www.example.org/exampleDocumen│
│t#G2"}                                                                │
├──────────────────────────────────────────────────────────────────────┤
│{"uri":"http://www.example.org/exampleDocument#Monica"}               │
└──────────────────────────────────────────────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid this, you can use <a href="https://neo4j-contrib.github.io/neo4j-apoc-procedures/#_nodes_collapse">APOC Nodes collapse</a>. <code>apoc.nodes.collapse</code> merges the set of nodes into a virtual node.</p>
</div>
<div class="paragraph">
<p>Here is the cypher snippet showing how to do that with the <code>exDoc:Monica</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (monica:Resource {uri: 'http://www.example.org/exampleDocument#Monica'})
WITH collect(monica) AS nodes
CALL apoc.nodes.collapse(nodes,{properties:'combine'}) YIELD from, rel, to
RETURN DISTINCT from AS monica</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result you will get a single node which looks like this in text mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════════════════════════════════════════════════════════════╕
│"monica"                                                              │
╞══════════════════════════════════════════════════════════════════════╡
│{"http://www.example.org/vocabulary#city":["New York"],"count":3,"http│
│://www.example.org/vocabulary#country":["USA"],"uri":"http://www.examp│
│le.org/exampleDocument#Monica","http://www.example.org/vocabulary#name│
│":["Monica Murphy"],"graphUri":["http://www.example.org/exampleDocumen│
│t#G2","http://www.example.org/exampleDocument#G1"]}                   │
└──────────────────────────────────────────────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find more information about the parameter configuration of <code>apoc.nodes.collapse</code> on <a href="https://neo4j-contrib.github.io/neo4j-apoc-procedures/#_nodes_collapse">APOC Nodes collapse</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advancedfetching"><a class="link" href="#advancedfetching">Advanced settings for fetching RDF</a></h3>
<div class="paragraph">
<p>Sometimes the RDF data will be a static file, and other times it&#8217;ll be dynamically generated in response to an HTTP request (<code>GET</code> or <code>POST</code>) possibly containg parameters, even a SPARQL query.
The following two parameters will help in these situations:
<code>payload</code> : Takes a String as value and sends the specified data in a POST HTTP request to the the url passed as first parameter of the Stored Procedure. Useful typicaloy for SPARQL endpoints where we want to submit a query to produce the actual RDF.
<code>headerParams</code> : Takes a map of property-values and adds each of them as an extra header in the HTTP request. Useful for sending credentials to services requiring authentication (using <code>Authorization</code> header) or to specify the required format (using <code>Accept</code> header).</p>
</div>
<div class="paragraph">
<p>Here is an example of how to send a request to a SPARQL endpoint and ingest the results directly in Neo4j. The service in question is the Linked Open Data service of the British Library. You can test it <a href="http://bnb.data.bl.uk/flint-sparql">here</a>. The service is not authenticated, so no need to use the <code>Authorization</code> header but we want to select the RDF serialisation produced by our request, which we do by setting <code>Accept: "application/turtle"</code>. Finally, we pass the SPARQL query as the value of the <code>payload</code> parameter, prefixed with <code>query=</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>headerParams: { Accept: "application/turtle"}, payload: "query=DESCRIBE &lt;http://bnb.data.bl.uk/id/resource/018212405&gt;" }</pre>
</div>
</div>
<div class="paragraph">
<p>We obviously need a query producing RDF so we can import it into Neo4j. I&#8217;m using a <a href="https://www.w3.org/TR/sparql11-query/#describe">SPARQL DESCRIBE</a> query in the following example but a <a href="https://www.w3.org/TR/sparql11-query/#construct">SPARQL CONSTRUCT</a> query could be used too. If you want to import all the details available in the British Library about 'The world of yesterday' by Stefan Zweig&#8217;s, which by the way, if you haven&#8217;t read, you should really take a break after this section and go read.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("https://bnb.data.bl.uk/sparql","Turtle",{ handleVocabUris: "IGNORE", headerParams: { Accept: "application/turtle"}, payload: "query=" + apoc.text.urlencode("DESCRIBE &lt;http://bnb.data.bl.uk/id/resource/018212405&gt;") })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the Bristish Library service requires you to encode the SPARQL query. We do this with <a href="https://neo4j-contrib.github.io/neo4j-apoc-procedures/#_overview_text_functions">APOC&#8217;s apoc.text.urlencode function</a>. After running this you get a pretty poor graph, because the
DESCRIBE query only returns the statements having 'The world of yesterday' (<code><a href="http://bnb.data.bl.uk/id/resource/018212405" class="bare">http://bnb.data.bl.uk/id/resource/018212405</a></code>) as subject or object.
But we can enrich it a bit by re-running it for a all of the URIs connected to our book as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">MATCH (:Book)--&gt;(t) WITH DISTINCT t
CALL n10s.importRDF("https://bnb.data.bl.uk/sparql","Turtle",{ handleVocabUris: "IGNORE", headerParams: { Accept: "application/turtle"}, payload: "query=" + apoc.text.urlencode("CONSTRUCT {&lt;" + t.uri + "&gt; ?p ?o } { &lt;" + t.uri + "&gt; ?p ?o } LIMIT 10 ")}) yield triplesLoaded
return t.uri, triplesLoaded</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒══════════════════════════════════════════════════════════════════════╤═══════════════╕
│"t.uri"                                                               │"triplesLoaded"│
╞══════════════════════════════════════════════════════════════════════╪═══════════════╡
│"http://bnb.data.bl.uk/id/person/ZweigStefan1881-1942"                │5              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://rdaregistry.info/termList/RDACarrierType/1018"                │1              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/place/lcsh/Europe"                  │4              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/lcsh/EuropeCivilization20thcentury" │5              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/resource/GBB721847"                         │1              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/place/Europe"                               │3              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://lexvo.org/id/iso639-3/eng"                                    │0              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/lcsh/WorldWar1914-1918Influence"    │5              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://rdaregistry.info/termList/RDAMediaType/1003"                  │1              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/lcsh/AuthorsAustrian20thcenturyBiogr│5              │
│aphy"                                                                 │               │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/resource/018212405/publicationevent/Placeofp│4              │
│ublicationnotidentifiedPushkinPress2009"                              │               │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://rdaregistry.info/termList/RDAContentType/1020"                │1              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/ddc/e22/838.91209"                  │3              │
├──────────────────────────────────────────────────────────────────────┼───────────────┤
│"http://bnb.data.bl.uk/id/concept/person/lcsh/ZweigStefan1881-1942"   │5              │
└──────────────────────────────────────────────────────────────────────┴───────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>And produces this graph:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/worldofyesterday.png" alt="Graph resulting of importing the data in the British National Library on 'The world of yesterday' by Stefan Zweig">
</div>
</div>
<div class="paragraph">
<p>Of course you could do achieve this -or something similar- in different ways, in this case we are using a SPARQL CONSTRUCT query in order to be able to limit
the number of triples returned for each resource as some of them are pretty dense.</p>
</div>
</div>
<div class="sect2">
<h3 id="custom_ns"><a class="link" href="#custom_ns">Defining custom prefixes for namespaces</a></h3>
<div class="paragraph">
<p>When applying url shortening on RDF ingestion (either explicitly or implicitly), we have the option of letting neosemantics automatically assign prefixes to namespaces as they appear in the imported RDF. But before doing that, a few popular ones will be set with familiar prefixes. These include <code>"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</code> prefixed as <code>rdf</code> and <code>"http://www.w3.org/2004/02/skos/core#"</code> prefixed as <code>skos</code>.</p>
</div>
<div class="paragraph">
<p>At any point you can check the prefixes in use by running the <code>listNamespacePrefixes</code> procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.listNamespacePrefixes()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before running your first import this method should return no results but after your first run, it should return a list containing at least the following entries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒════════╤═════════════════════════════════════════════╕
│"prefix"│"namespace"                                  │
╞════════╪═════════════════════════════════════════════╡
│"skos"  │"http://www.w3.org/2004/02/skos/core#"       │
├────────┼─────────────────────────────────────────────┤
│"sch"   │"http://schema.org/"                         │
├────────┼─────────────────────────────────────────────┤
│"sh"    │"http://www.w3.org/ns/shacl#"                │
├────────┼─────────────────────────────────────────────┤
│"rdfs"  │"http://www.w3.org/2000/01/rdf-schema#"      │
├────────┼─────────────────────────────────────────────┤
│"dc"    │"http://purl.org/dc/elements/1.1/"           │
├────────┼─────────────────────────────────────────────┤
│"dct"   │"http://purl.org/dc/terms/"                  │
├────────┼─────────────────────────────────────────────┤
│"rdf"   │"http://www.w3.org/1999/02/22-rdf-syntax-ns#"│
├────────┼─────────────────────────────────────────────┤
│"owl"   │"http://www.w3.org/2002/07/owl#"             │
└────────┴─────────────────────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say the RDF dataset that you are going to import uses the namespace <code><a href="http://neo4j.org/voc/sw#" class="bare">http://neo4j.org/voc/sw#</a></code> and you want it to be prefixed as <code>neo</code> instead of <code>ns0</code> (or <code>ns7</code>) as would happen if the prefix was assigned automatically by neosemantics.
You can do this by calling the <code>addNamespacePrefix</code> procedure as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">call n10s.addNamespacePrefix("neo","http://neo4j.org/vocab/sw#")</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will return:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">╒════════╤════════════════════════════╕
│"prefix"│"namespace"                 │
╞════════╪════════════════════════════╡
│"neo"   │"http://neo4j.org/vocab/sw#"│
└────────┴────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then when the namespace is detected during the ingestion of the RDF data, the <code>neo</code> prefix will be used.</p>
</div>
<div class="paragraph">
<p>Make sure you know what you&#8217;re doing if you manipulate the prefix definition, especially after loading RDF data as you can overwrite namespaces in use, which would affect the possibility of regenerating the imported RDF.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="DeleteRDF"><a class="link" href="#DeleteRDF">Deleting RDF</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The method to delete imported RDF data is <code>n10s.deleteRDF</code>. It deletes from Neo4j the triples returned by an url. This url can point to an RDF file (local or remote) or a service producing RDF dynamically.
All delete procedures take the following three parameters, like the import procedures:</p>
</div>
<table id="common_params_delete" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL of the dataset</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">format</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">serialization format. Valid formats are: Turtle, N-Triples, JSON-LD, RDF/XML, <strong>TriG and N-Quads</strong> (For named graphs)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">params</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set of parameters (see description in table below)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In its most basic form the <code>n10s.deleteRDF</code> method just takes the url string to access the RDF data and the serialisation format.
Let&#8217;s say you have already imported the following set of triples into Neo4j with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/deleteRDF/dataset.ttl","Turtle",{typesToLabels: true, keepCustomDataTypes: true, handleMultival: 'ARRAY'})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://example.org/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:Resource1
  a ex:TestResource ;
  ex:Predicate1 "100"^^ex:CDT ;
  ex:Predicate2 "test";
  ex:Predicate3 ex:Resource2 ;
  ex:Predicate4 "val1" ;
  ex:Predicate4 "val2" ;
  ex:Predicate4 "val3" ;
  ex:Predicate4 "val4" .

ex:Resource2
  a ex:TestResource ;
  ex:Predicate1 "test";
  ex:Predicate2 ex:Resource3 ;
  ex:Predicate3 "100"^^xsd:long ;
  ex:Predicate3 "200"^^xsd:long ;
  ex:Predicate4 "300.0"^^xsd:double ;
  ex:Predicate4 "400.0"^^xsd:double .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say you&#8217;re trying to delete the following set of triples from Neo4j after the import above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://example.org/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:Resource1
  ex:Predicate3 ex:Resource2 .

ex:Resource2
  a ex:TestResource ;
  ex:Predicate1 "test";
  ex:Predicate2 ex:Resource3 ;
  ex:Predicate3 "100"^^xsd:long ;
  ex:Predicate3 "200"^^xsd:long ;
  ex:Predicate4 "300.0"^^xsd:double ;
  ex:Predicate4 "400.0"^^xsd:double .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the cypher snippet showing how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.deleteRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/deleteRDF/delete.ttl","Turtle",{typesToLabels: true, keepCustomDataTypes: true, handleMultival: 'ARRAY'})</code></pre>
</div>
</div>
<div class="paragraph">
<p>NSMNTX will delete the RDF data in your Neo4j graph. After this deletion your RDF data will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://example.org/&gt; .

ex:Resource1
  a ex:TestResource ;
  ex:Predicate1 "100"^^ex:CDT ;
  ex:Predicate2 "test";
  ex:Predicate4 "val1" ;
  ex:Predicate4 "val2" ;
  ex:Predicate4 "val3" ;
  ex:Predicate4 "val4" .</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You <strong>must</strong> use for deletion the same set of parameters that you used during import, otherwise you will not get the expected results.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Note</strong> that currently blank nodes cannot be deleted due to not having a persistent IRI.</p>
</div>
<div class="sect2">
<h3 id="_handling_named_graphs_rdf_quads"><a class="link" href="#_handling_named_graphs_rdf_quads">Handling named graphs (RDF Quads)</a></h3>
<div class="paragraph">
<p>You can also delete imported quads using <code>n10s.deleteQuadRDF</code> which takes the same generic params described in <a href="#common_params_delete">[common_params_delete]</a>.</p>
</div>
<div class="paragraph">
<p><strong>Note</strong> that you need to use TriG or N-Quads serializations if you want to take advantage of the named graph function.</p>
</div>
<div class="paragraph">
<p>For this example we will use the same dataset which was used in <a href="#ImportQuadRDF">Handling named graphs (RDF Quads)</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you&#8217;re trying to delete the following set of quads from Neo4j after the import from the <a href="#ImportQuadRDF">Handling named graphs (RDF Quads)</a> section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://www.example.org/vocabulary#&gt; .
@prefix exDoc: &lt;http://www.example.org/exampleDocument#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

exDoc:G2 ex:created "2019-06-07T10:15:30"^^xsd:dateTime .

exDoc:Monica a ex:Person ;
             ex:friendOf exDoc:John .

exDoc:G1 {
    exDoc:Monica
              ex:name "Monica Murphy" ;
              ex:email &lt;mailto:monica@monicamurphy.org&gt; ;
              ex:hasSkill ex:Management ;
              ex:knows exDoc:John . }

exDoc:G2 {
    exDoc:Monica
              ex:city "New York" ;
              ex:country "USA" . }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>n10s.deleteQuadRDF</code> procedure takes the same generic params described in <a href="#common_params_delete">[common_params_delete]</a> at the beginning of the <a href="#DeleteRDF">Deleting RDF</a> section, so we will invoke it with a URL and a serialisation format. In the following example we will import the RDF dataset in <a href="docs/rdf/RDFDataset/RDFDataset.trig">this file</a>.</p>
</div>
<div class="paragraph">
<p>Here is the cypher snippet showing how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.deleteQuadRDF("file:///Users/emrearkan/IdeaProjects/neosemantics/docs/rdf/RDFDataset/RDFDataset.trig","TriG",{typesToLabels: true, keepCustomDataTypes: true, handleMultival: 'ARRAY'})</code></pre>
</div>
</div>
<div class="paragraph">
<p>NSMNTX will delete the given quads in your Neo4j graph. After this deletion your RDF dataset will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix ex: &lt;http://www.example.org/vocabulary#&gt; .
@prefix exDoc: &lt;http://www.example.org/exampleDocument#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

exDoc:G1 ex:created "2019-06-06"^^xsd:date .

exDoc:G1 {
    exDoc:Monica
              ex:homepage &lt;http://www.monicamurphy.org&gt; ;
              ex:hasSkill ex:Programming . }

exDoc:G3 {
    exDoc:John a ex:Person . }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="OntoImport"><a class="link" href="#OntoImport">Importing Ontologies</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ontologies are serialised as RDF, so they can be imported using plain <code>importRDF</code> but the <code>liteOntoImport</code> method will give us a higher level of control over how an RDFS or OWL ontology is imported into Neo4j. It&#8217;s important to note that this procedure exclusively import the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Named class (category) declarations with both <code>rdfs:Class</code> and <code>owl:Class</code>.</p>
</li>
<li>
<p>Explicit class hierarchies defined with <code>rdf:subClassOf</code> statements.</p>
</li>
<li>
<p>Property definitions with <code>owl:ObjectProperty</code>, <code>owl:DatatypeProperty</code> and <code>rdfs:Property</code></p>
</li>
<li>
<p>Explicit property hierarchies defined with <code>rdfs:subPropertyOf</code> statements.</p>
</li>
<li>
<p>Domain and range information for properties described as <code>rdfs:domain</code> and <code>rdfs:range</code> statements.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All other elments will be ignored by this loader.</p>
</div>
<div class="paragraph">
<p>The <code>liteOntoImport</code> procedure takes the same generic params described in <a href="#common_params">[common_params]</a> at the beginning of the <a href="#Import">Importing RDF data</a> section, so we will invoke it with a URL and a serialisation format. In the following example we will import the ontology in <a href="docs/rdf/vw.owl">this file</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importOntology("http://jbarrasa.github.io/neosemantics/docs/rdf/vw.owl","Turtle")</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/vwonto.png" alt="VW ontology imported in Neo4j">
</div>
</div>
<div class="paragraph">
<p>As we see in the ingested graph, by default, classes will be persissted as nodes with label <code>Class</code> with two properties: uri and name and <code>rdf:subClassOf</code> statements are stored ass relationships of type <code>SCO</code> between <code>Class</code> nodes. Similarly, relationships will be persisted as nodes with name and uri and labels <code>Relationship</code> or <code>Property</code> for <code>owl:ObjectProperty</code> and <code>owl:DatatypeProperty</code> respectively. Statements with <code>rdf:subPropertyOf</code> as predicate are stored as relationships of type <code>SPO</code> between <code>Relationship</code> or <code>Property</code> nodes.</p>
</div>
<div class="paragraph">
<p>These graph model elements can be overriden by using the following configuration params:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>classLabel</strong>: Label to be used for Ontology Classes (categories). Default is <code>Class</code>.</p>
</li>
<li>
<p><strong>subClassOfRel</strong>: Relationship to be used for <code>rdfs:subClassOf</code> hierarchies. Default is <code>SCO</code>.</p>
</li>
<li>
<p><strong>dataTypePropertyLabel</strong>: Label to be used for DataType properties in the Ontology. Default is <code>Property</code>.</p>
</li>
<li>
<p><strong>objectPropertyLabel</strong>: Label to be used for Object properties in the Ontology. Default is <code>Relationship</code>.</p>
</li>
<li>
<p><strong>subPropertyOfRel</strong>: Relationship to be used for <code>rdfs:subPropertyOf</code> hierarchies. Default is <code>SPO</code>.</p>
</li>
<li>
<p><strong>domainRel</strong>: Relationship to be used for <code>rdfs:domain</code>. Default is <code>DOMAIN</code>.</p>
</li>
<li>
<p><strong>rangeRel</strong>: Relationship to be used for <code>rdfs:range</code>. Default is <code>RANGE</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of how to load an ontology using some of these parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.importOntology("http://jbarrasa.github.io/neosemantics/docs/rdf/vw.owl","Turtle", { classLabel : 'Category', objectPropertyLabel: 'Rel', dataTypePropertyLabel: 'Prop'})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it&#8217;s also possible to have imported nodes (both Classes and Properties/Relationships) labeled as <code>Resource</code> for compatibility with the importRDF procedure. This is done by setting the <code>addResourceLabels</code> parameter to <code>true</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Preview"><a class="link" href="#Preview">Previewing RDF data</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes before we go ahead and import RDF data into Neo4j we want to see what it looks like or we may even want to take full control with Cypher over the data ingestion process and customise what to do with each parsed triple. For these purpose NSMNTX provides the following procedures.</p>
</div>
<div class="sect2">
<h3 id="_streaming_triples"><a class="link" href="#_streaming_triples">Streaming triples</a></h3>
<div class="paragraph">
<p>The <code>streamRDF</code> procedure also takes the same generic params described in <a href="#common_params">[common_params]</a>, so we will invoke it with a URL and a serialisation format just as we would invoke the <code>importRDF</code> procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.streamRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/nsmntx.ttl","Turtle")</code></pre>
</div>
</div>
<div class="paragraph">
<p>It will produce a stream of records, each one representing a triple parsed. So you will get fields for the subject, predicate and object plus three additional ones:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>isLiteral</strong>: a boolean indicating whether the object of the statement is a literal</p>
</li>
<li>
<p><strong>literalType</strong>: The datatype of the literal value when available</p>
</li>
<li>
<p><strong>literalLang</strong>: The language when available</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the previous example the output would look something like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/streamRDF.png" alt="RDF parsed and streamed in Neo4j">
</div>
</div>
<div class="paragraph">
<p>The procedure is read-only and nothing is written to the graph, however, it is possible to use cypher on the output of the procedure to analyse the triples returned like in this first example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.streamRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/nsmntx.ttl","Turtle") yield subject, predicate, object
WHERE predicate = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
RETURN object as category, count(*) as itemsInCategory</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>╒═══════════════════════════════════════════╤═════════════════╕
│"category"                                 │"itemsInCategory"│
╞═══════════════════════════════════════════╪═════════════════╡
│"http://neo4j.org/vocab/sw#Neo4jPlugin"    │3                │
├───────────────────────────────────────────┼─────────────────┤
│"http://neo4j.org/vocab/sw#GraphPlatform"  │1                │
├───────────────────────────────────────────┼─────────────────┤
│"http://neo4j.org/vocab/sw#AwesomePlatform"│1                │
└───────────────────────────────────────────┴─────────────────┘</pre>
</div>
</div>
<div class="paragraph">
<p>Or even to write to the Graph to create your own custom structure like in this second one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cypher" data-lang="cypher">CALL n10s.streamRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/nsmntx.ttl","Turtle")
YIELD subject, predicate, object, isLiteral
WHERE NOT ( isLiteral OR predicate = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" )
MERGE (from:Thing { id: subject})
MERGE (to:Thing { id: object })
MERGE (from)-[:CONNECTED_TO { id: predicate }]-&gt;(to)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_previewing_rdf_data"><a class="link" href="#_previewing_rdf_data">Previewing RDF data</a></h3>
<div class="paragraph">
<p>The <code>previewRDF</code> and <code>previewRDFSnippet</code> methods provide a convenient way to visualise in the Neo4j browser some RDF data before we go ahead with the actual import. Like all methods in the <a href="#Preview">Previewing RDF data</a> section, both <code>previewRDF</code> and <code>previewRDFSnippet</code> are read only so will not persist anything in the graph. The difference between them is that <code>previewRDF</code> takes a url (and optionally additional configuration settings as described in  <a href="#advancedfetching">Advanced settings for fetching RDF</a>) whereas <code>previewRDFSnippet</code> takes an RDF fragment as text instead.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Export"><a class="link" href="#Export">Exporting RDF data</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous section we covered how to ingest RDF into Neo4j, in this one we will focus on how to generate RDF from our Neo4j graph. We will see that it is possible to serialise in RDF any Neo4j graph, even in the case when the data in Neo4j is not the result of importing RDF.</p>
</div>
<div class="paragraph">
<p>RDF is a W3C standard model for data interchange on the Web that represents data as a graph, hence the seamless serialisation of graph data from Neo4j in RDF as we&#8217;ll see.</p>
</div>
<div class="paragraph">
<p>There are three main ways of generating RDF from your graph in Neo4j. Selecting a node in the graph by its unique identifier (id or uri), selecting a group of nodes by Label + property value and via Cypher. Let&#8217;s analyse each of them in detail.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The paths used in the following sections assume that NSMNTX is mounted at <code>/rdf</code>. If you&#8217;ve mounted the extension under a different name (instructions on how to do this can be found in the <a href="#install">[install]</a> section) all you need to do is replace the <code>/rdf</code> bits in the urls in the following examples with the name you&#8217;ve used.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_by_node_id"><a class="link" href="#_by_node_id">By node ID</a></h3>
<div class="sect3">
<h4 id="_rdf_describe_id"><a class="link" href="#_rdf_describe_id">/rdf/describe/id</a></h4>
<div class="paragraph">
<p>To explain how some this method works, we&#8217;ll use the Northwind Graph. You can easily load it in your Neo4j instance by running <code>:play northwind-graph</code> in your browser. This will bring up a guide with step by step instructions on how to create it. I&#8217;ll assume the graph is now loaded.</p>
</div>
<div class="paragraph">
<p>The describe/id method emulates the SPARQL DESCRIBE operation. It takes the unique identifier of an element in the graph and it produces an RDF serialisation of all information available about it. This includes properties, labels, and relationships (both incoming and outgoing).</p>
</div>
<div class="paragraph">
<p>The only required parameter is the id of the node. As you know any node in Neo4j has a unique identifier that you can get via cypher using the <code>id</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (p:Product) WHERE p.productName = "Queso Manchego La Pastora" RETURN ID(p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In my case, the <code>ID</code> returned by the previous query is <code>11</code>, so if I want NSMNTX to produce an RDF serialisation of this node, all I need to do is issue the following HTTP request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-HTTP" data-lang="HTTP">http://localhost:7474/rdf/describe/id/11</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or if you&#8217;re working on your Neo4j browser, you can run it like this too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/id/11</code></pre>
</div>
</div>
<div class="paragraph">
<p>And you will get a description for your node, serialised as Turtle RDF by default. Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Turtle" data-lang="Turtle">@prefix neovoc: &lt;neo4j://vocabulary#&gt; .
@prefix neoind: &lt;neo4j://individuals#&gt; .


neoind:11 a neovoc:Product;
  neovoc:PART_OF neoind:83;
  neovoc:categoryID "4";
  neovoc:discontinued false;
  neovoc:productID "12";
  neovoc:productName "Queso Manchego La Pastora";
  neovoc:quantityPerUnit "10 - 500 g pkgs.";
  neovoc:reorderLevel "0"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:supplierID "5";
  neovoc:unitPrice 3.8E1;
  neovoc:unitsInStock "86"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:unitsOnOrder "0"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt; .

neoind:1038 neovoc:ORDERS neoind:11 .
neoind:684 neovoc:ORDERS neoind:11 .
neoind:1035 neovoc:ORDERS neoind:11 .
neoind:525 neovoc:ORDERS neoind:11 .
neoind:622 neovoc:ORDERS neoind:11 .
neoind:968 neovoc:ORDERS neoind:11 .
neoind:532 neovoc:ORDERS neoind:11 .
neoind:667 neovoc:ORDERS neoind:11 .
neoind:957 neovoc:ORDERS neoind:11 .
neoind:1007 neovoc:ORDERS neoind:11 .
neoind:707 neovoc:ORDERS neoind:11 .
neoind:255 neovoc:ORDERS neoind:11 .
neoind:1066 neovoc:ORDERS neoind:11 .
neoind:428 neovoc:ORDERS neoind:11 .
neoind:104 neovoc:SUPPLIES neoind:11 .</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can modify the output of the describe method as follows:
* Change serialisation format by either by using the <code>accept</code> header param with any of the RDF media types: <code>"application/rdf+xml", "text/plain", "text/turtle", "text/n3", "application/trix", "application/x-trig", "application/ld+json"</code> or the <code>format</code> request param using any of the following values: <code>Turtle, N-Triples, JSON-LD, TriG, RDF/XML</code>. The <code>format</code> request parameter if used will override the <code>accept</code> header param.
* Exclude relationships and just return the properties and labels of the selected node by setting the request parameter <code>exculdeContext</code> to <code>true</code>.
* Exclude unmapped elements by setting the request parameter <code>showOnlyMapped</code> to true. We&#8217;ll see in section <a href="#Mapping">Mapping graph models</a> how to define basic model mappings with NSMNTX.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of using some of this modifiers. The following request (again simplified notation for the Neo4j browser):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/id/11?format=RDF/XML&amp;excludeContext=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Would filter out relationships (RDF Object Properties) and set the serialisation format to <code>RDF/XML</code> to produce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF/XML" data-lang="RDF/XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF
	xmlns:neovoc="neo4j://vocabulary#"
	xmlns:neoind="neo4j://individuals#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#11"&gt;
	&lt;rdf:type rdf:resource="neo4j://vocabulary#Product"/&gt;
	&lt;neovoc:reorderLevel rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;0&lt;/neovoc:reorderLevel&gt;
	&lt;neovoc:unitsInStock rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;86&lt;/neovoc:unitsInStock&gt;
	&lt;neovoc:unitPrice rdf:datatype="http://www.w3.org/2001/XMLSchema#double"&gt;38.0&lt;/neovoc:unitPrice&gt;
	&lt;neovoc:supplierID&gt;5&lt;/neovoc:supplierID&gt;
	&lt;neovoc:productID&gt;12&lt;/neovoc:productID&gt;
	&lt;neovoc:quantityPerUnit&gt;10 - 500 g pkgs.&lt;/neovoc:quantityPerUnit&gt;
	&lt;neovoc:discontinued rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;false&lt;/neovoc:discontinued&gt;
	&lt;neovoc:productName&gt;Queso Manchego La Pastora&lt;/neovoc:productName&gt;
	&lt;neovoc:categoryID&gt;4&lt;/neovoc:categoryID&gt;
	&lt;neovoc:unitsOnOrder rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;0&lt;/neovoc:unitsOnOrder&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_by_uri"><a class="link" href="#_by_uri">By URI</a></h3>
<div class="sect3">
<h4 id="_rdf_describe_uri"><a class="link" href="#_rdf_describe_uri">/rdf/describe/uri</a></h4>
<div class="paragraph">
<p>If you&#8217;ve imported an RDF dataset using NSMNTX (and you did NOT use the <code>IGNORE</code> option) now you can export it and generate exactly the same set of RDF triples that were originally ingested. You can do this in a very similar way to how you do it for any other Neo4j graph. The <code>/rdf/describe/uri</code> works exactly in the same way as the <code>/rdf/describe/id</code> but instead of taking a node&#8217;s ID, it takes it&#8217;s URI. Here&#8217;s an example on the graph we imported in section <a href="#import">[import]</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/uri/http%3A%2F%2Fneo4j.org%2Find%23neo4j355?format=RDF/XML</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, notice the URL enconding of the URI (the clean URI is <code><a href="http://neo4j.org/ind#neo4j355" class="bare">http://neo4j.org/ind#neo4j355</a></code>) and the <code>format</code> parameter to specify the serialisation format. Here&#8217;s the output of the request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF
	xmlns:neovoc="neo4j://vocabulary#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

&lt;rdf:Description rdf:about="http://neo4j.org/ind#neo4j355"&gt;
	&lt;rdf:type rdf:resource="http://neo4j.org/vocab/sw#GraphPlatform"/&gt;
	&lt;rdf:type rdf:resource="http://neo4j.org/vocab/sw#AwesomePlatform"/&gt;
	&lt;name xmlns="http://neo4j.org/vocab/sw#"&gt;neo4j&lt;/name&gt;
	&lt;version xmlns="http://neo4j.org/vocab/sw#"&gt;3.5.5&lt;/version&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="http://neo4j.org/ind#graphql3502"&gt;
	&lt;runsOn xmlns="http://neo4j.org/vocab/sw#" rdf:resource="http://neo4j.org/ind#neo4j355"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="http://neo4j.org/ind#nsmntx3502"&gt;
	&lt;runsOn xmlns="http://neo4j.org/vocab/sw#" rdf:resource="http://neo4j.org/ind#neo4j355"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="http://neo4j.org/ind#apoc3502"&gt;
	&lt;runsOn xmlns="http://neo4j.org/vocab/sw#" rdf:resource="http://neo4j.org/ind#neo4j355"/&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, you can provide a graph URI to specify the context of the given resource using the <code>graphuri</code> parameter.
Here is how you can serialise as RDF the resource identified by URI <code><a href="http://www.example.org/exampleDocument#Monica" class="bare">http://www.example.org/exampleDocument#Monica</a></code>
but only the statements in the named graph <code><a href="http://www.example.org/exampleDocument#G1" class="bare">http://www.example.org/exampleDocument#G1</a></code>. Normally such a model will
 be the result of importing RDF Quads as described in the <a href="#ImportQuadRDF">Handling named graphs (RDF Quads)</a> section. Note that URIS are URL encoded:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/uri/http%3A%2F%2Fwww.example.org%2FexampleDocument%23Monica?graphuri=http%3A%2F%2Fwww.example.org%2FexampleDocument%23G1&amp;format=TriG</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_by_label_property_value"><a class="link" href="#_by_label_property_value">By Label + property value</a></h3>
<div class="sect3">
<h4 id="_rdf_describe_find"><a class="link" href="#_rdf_describe_find">/rdf/describe/find/</a></h4>
<div class="paragraph">
<p>An alternative way to select he node (or set of nodes) to serialise as RDF is to do a search by label and property. Let&#8217;s say in our Northwind Database example we want to get the Suppliers in a given postal code. The label we&#8217;re interested in is <code>Supplier</code> and the property is <code>postcode</code>. Here&#8217;s what a request of this type would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/find/Supplier/postalCode/EC1%204SD?format=N-Triples</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this request we are setting the serialisation to N-Triples format. Also notice that the property value (EC1 4SD) needs to be URL Encoded. Here&#8217;s the output of the request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">&lt;neo4j://individuals#100&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;neo4j://vocabulary#Supplier&gt; .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#country&gt; "UK" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#contactTitle&gt; "Purchasing Manager" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#address&gt; "49 Gilbert St." .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#supplierID&gt; "1" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#phone&gt; "(171) 555-2222" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#city&gt; "London" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#contactName&gt; "Charlotte Cooper" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#companyName&gt; "Exotic Liquids" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#postalCode&gt; "EC1 4SD" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#region&gt; "NULL" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#fax&gt; "NULL" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#homePage&gt; "NULL" .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#SUPPLIES&gt; &lt;neo4j://individuals#0&gt; .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#SUPPLIES&gt; &lt;neo4j://individuals#1&gt; .
&lt;neo4j://individuals#100&gt; &lt;neo4j://vocabulary#SUPPLIES&gt; &lt;neo4j://individuals#2&gt; .</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default property values are treated as strings which may or may not work depending on the actual datatype stored in the node property in the Database. If you need to specify the datatype, you&#8217;ll need the <code>valType</code> parameter. The following request returns all products with a given price point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/describe/find/Product/unitPrice/15?valType=INTEGER&amp;excludeContext</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how we are being explicit about the datatype using the <code>valType</code> request parameter. If we removed this parameter the request would return no results because there is no Product in the Northwind Database with a <code>unitPrice</code> stored as a string.
Here&#8217;s the ouptut produced (default serialisation is Turtle).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix neovoc: &lt;neo4j://vocabulary#&gt; .
@prefix neoind: &lt;neo4j://individuals#&gt; .


neoind:69 a neovoc:Product;
  neovoc:categoryID "1";
  neovoc:discontinued false;
  neovoc:productID "70";
  neovoc:productName "Outback Lager";
  neovoc:quantityPerUnit "24 - 355 ml bottles";
  neovoc:reorderLevel "30"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:supplierID "7";
  neovoc:unitPrice 1.5E1;
  neovoc:unitsInStock "15"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:unitsOnOrder "10"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt; .

neoind:72 a neovoc:Product;
  neovoc:categoryID "8";
  neovoc:discontinued false;
  neovoc:productID "73";
  neovoc:productName "Röd Kaviar";
  neovoc:quantityPerUnit "24 - 150 g jars";
  neovoc:reorderLevel "5"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:supplierID "17";
  neovoc:unitPrice 1.5E1;
  neovoc:unitsInStock "101"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt;;
  neovoc:unitsOnOrder "0"^^&lt;http://www.w3.org/2001/XMLSchema#long&gt; .</code></pre>
</div>
</div>
<div class="paragraph">
<p>The different values that the <code>valType</code> request parameter can take are currently: <code>INTEGER</code>, <code>FLOAT</code> and <code>BOOLEAN</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_cypher"><a class="link" href="#_using_cypher">Using Cypher</a></h3>
<div class="sect3">
<h4 id="_rdf_cypher"><a class="link" href="#_rdf_cypher">/rdf/cypher</a></h4>
<div class="paragraph">
<p>Finally, the most powerful way of selecting the portion of the graph that we want to serialise as cypher would obviously be to use Cypher. That&#8217;s exactly what this method does. In this case it&#8217;s a POST request that takes as payload a JSON map with at least one <code>cypher</code> key having as its value the query returning the graph objects (nodes with their properties and relationships) to be serialised.</p>
</div>
<div class="paragraph">
<p>Optionally, the JSON map may include the <code>format</code> key that can be used to override the default serialization format (Turtle) and also a <code>showOnlyMapped</code> key (default value is <code>false</code>). Whe present, the returned serialisation will exclude unmapped elements (same functionality explained in the <code>describe</code> methods). Here&#8217;s an example of use on the Northwind database. Note that your query needs to return graph elements: nodes, relationships or paths. Produces an RDF serialization of the nodes and relationships returned by the query.&lt;br&gt;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:POST /rdf/cypher
{ "cypher" : "MATCH path = (n:Customer { customerID : 'GROSR'})-[:PURCHASED]-&gt;(o)-[:ORDERS]-&gt;()-[:PART_OF]-&gt;(:Category { categoryName : 'Beverages'}) RETURN path " , "format": "RDF/XML" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the subgraph (path) that we are serialising as RDF. We&#8217;re taking a customer by its <code>customerID</code> and getting all orders containing items in category <code>Beverages</code>. Nice path expression in Cypher :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/customer-order-product-neo4j.png" alt="Customer" width="order" height="product">
</div>
</div>
<div class="paragraph">
<p>And this is the generated RDF/XML.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF
	xmlns:neovoc="neo4j://vocabulary#"
	xmlns:neoind="neo4j://individuals#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#172"&gt;
	&lt;rdf:type rdf:resource="neo4j://vocabulary#Customer"/&gt;
	&lt;neovoc:country&gt;Venezuela&lt;/neovoc:country&gt;
	&lt;neovoc:address&gt;5ª Ave. Los Palos Grandes&lt;/neovoc:address&gt;
	&lt;neovoc:contactTitle&gt;Owner&lt;/neovoc:contactTitle&gt;
	&lt;neovoc:city&gt;Caracas&lt;/neovoc:city&gt;
	&lt;neovoc:phone&gt;(2) 283-2951&lt;/neovoc:phone&gt;
	&lt;neovoc:contactName&gt;Manuel Pereira&lt;/neovoc:contactName&gt;
	&lt;neovoc:companyName&gt;GROSELLA-Restaurante&lt;/neovoc:companyName&gt;
	&lt;neovoc:postalCode&gt;1081&lt;/neovoc:postalCode&gt;
	&lt;neovoc:customerID&gt;GROSR&lt;/neovoc:customerID&gt;
	&lt;neovoc:fax&gt;(2) 283-3397&lt;/neovoc:fax&gt;
	&lt;neovoc:region&gt;DF&lt;/neovoc:region&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#774"&gt;
	&lt;rdf:type rdf:resource="neo4j://vocabulary#Order"/&gt;
	&lt;neovoc:shipCity&gt;Caracas&lt;/neovoc:shipCity&gt;
	&lt;neovoc:orderID&gt;10785&lt;/neovoc:orderID&gt;
	&lt;neovoc:freight&gt;1.51&lt;/neovoc:freight&gt;
	&lt;neovoc:requiredDate&gt;1998-01-15 00:00:00.000&lt;/neovoc:requiredDate&gt;
	&lt;neovoc:employeeID&gt;1&lt;/neovoc:employeeID&gt;
	&lt;neovoc:shipPostalCode&gt;1081&lt;/neovoc:shipPostalCode&gt;
	&lt;neovoc:shipName&gt;GROSELLA-Restaurante&lt;/neovoc:shipName&gt;
	&lt;neovoc:shipCountry&gt;Venezuela&lt;/neovoc:shipCountry&gt;
	&lt;neovoc:shipAddress&gt;5ª Ave. Los Palos Grandes&lt;/neovoc:shipAddress&gt;
	&lt;neovoc:shipVia&gt;3&lt;/neovoc:shipVia&gt;
	&lt;neovoc:customerID&gt;GROSR&lt;/neovoc:customerID&gt;
	&lt;neovoc:shipRegion&gt;DF&lt;/neovoc:shipRegion&gt;
	&lt;neovoc:shippedDate&gt;1997-12-24 00:00:00.000&lt;/neovoc:shippedDate&gt;
	&lt;neovoc:orderDate&gt;1997-12-18 00:00:00.000&lt;/neovoc:orderDate&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#74"&gt;
	&lt;rdf:type rdf:resource="neo4j://vocabulary#Product"/&gt;
	&lt;neovoc:reorderLevel rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;25&lt;/neovoc:reorderLevel&gt;
	&lt;neovoc:unitsInStock rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;125&lt;/neovoc:unitsInStock&gt;
	&lt;neovoc:unitPrice rdf:datatype="http://www.w3.org/2001/XMLSchema#double"&gt;7.75&lt;/neovoc:unitPrice&gt;
	&lt;neovoc:supplierID&gt;12&lt;/neovoc:supplierID&gt;
	&lt;neovoc:productID&gt;75&lt;/neovoc:productID&gt;
	&lt;neovoc:quantityPerUnit&gt;24 - 0.5 l bottles&lt;/neovoc:quantityPerUnit&gt;
	&lt;neovoc:discontinued rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;false&lt;/neovoc:discontinued&gt;
	&lt;neovoc:productName&gt;Rhönbräu Klosterbier&lt;/neovoc:productName&gt;
	&lt;neovoc:categoryID&gt;1&lt;/neovoc:categoryID&gt;
	&lt;neovoc:unitsOnOrder rdf:datatype="http://www.w3.org/2001/XMLSchema#long"&gt;0&lt;/neovoc:unitsOnOrder&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#80"&gt;
	&lt;rdf:type rdf:resource="neo4j://vocabulary#Category"/&gt;
	&lt;neovoc:description&gt;Soft drinks, coffees, teas, beers, and ales&lt;/neovoc:description&gt;
	&lt;neovoc:categoryName&gt;Beverages&lt;/neovoc:categoryName&gt;
	&lt;neovoc:picture&gt;0x151C2F00020000000D000E0014002100FFFFFFFF4269746D617020496D616765005061696E742E5069637475726500010500000200000007000000504272757368000000000000000000A0290000424D98290000000000005600000028000000AC00000078000000010004000000000000000000880B0000880B0000080000&lt;/neovoc:picture&gt;
	&lt;neovoc:categoryID&gt;1&lt;/neovoc:categoryID&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#172"&gt;
	&lt;neovoc:PURCHASED rdf:resource="neo4j://individuals#774"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#774"&gt;
	&lt;neovoc:ORDERS rdf:resource="neo4j://individuals#74"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://individuals#74"&gt;
	&lt;neovoc:PART_OF rdf:resource="neo4j://individuals#80"/&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here&#8217;s the graph visualisation produced by the <a href="https://www.w3.org/RDF/Validator/">W3C&#8217;s RDF validation service</a> for this RDF. Feel free to test the parsing of the generated RDF yourself. You can do it manually copy-pasting it in the form, or you can point directly to your Neo4j instance RDF endpoint if the URL is publicly accessible.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/customer-order-product-rdf.png" alt="RDF Graph visualisation generated by W3C RDF Validation service">
</div>
</div>
<div class="paragraph">
<p>It is possible to pass parameters to the query using the <code>cypherParams</code> parameter in the request. And you should be using params whenever possible. Here&#8217;s exactly the same request but passing the customerID as a parameter to the cypher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:POST /rdf/cypher
{ "cypher" : "MATCH path = (n:Customer { customerID : $custid })-[:PURCHASED]-&gt;(o)-[:ORDERS]-&gt;()-[:PART_OF]-&gt;(:Category { categoryName : 'Beverages'}) RETURN path " , "cypherParams" : { "custid": "GROSR" }, "format": "RDF/XML" }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rdf_cypheronrdf"><a class="link" href="#_rdf_cypheronrdf">/rdf/cypheronrdf</a></h4>
<div class="paragraph">
<p>And finally, if the graph in your Neo4j DB is the result of importing an RDF dataset using NSMNTX (and of course if you did NOT use the <code>IGNORE</code> option), <code>rdf/cypheronrdf</code> will work in exactly the same way as <code>rdf/cypher</code> but will use the stored namespace information to generate exactly the same RDF triples that were originally ingested. The parameters are identical to the previous case. Here&#8217;s an example on the graph we imported in section <a href="#import">[import]</a> that returns a plugin information given a <code>releaseDate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:POST /rdf/cypheronrdf { "cypher":"MATCH (neo4j:ns0__GraphPlatform)&lt;-[ro:ns0__runsOn]-(plugin:ns0__Neo4jPlugin) WHERE plugin.ns0__releaseDate = '03-06-2019' RETURN plugin, ro, neo4j " , "format" : "JSON-LD"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use this example to set the serialisation format to <code>JSON-LD</code>, which would produce the following RDF fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">[ {
  "@id" : "http://neo4j.org/ind#neo4j355",
  "@type" : [ "http://neo4j.org/vocab/sw#GraphPlatform", "http://neo4j.org/vocab/sw#AwesomePlatform" ],
  "http://neo4j.org/vocab/sw#name" : [ {
    "@value" : "neo4j"
  } ],
  "http://neo4j.org/vocab/sw#version" : [ {
    "@value" : "3.5.5"
  } ]
}, {
  "@id" : "http://neo4j.org/ind#nsmntx3502",
  "@type" : [ "http://neo4j.org/vocab/sw#Neo4jPlugin" ],
  "http://neo4j.org/vocab/sw#name" : [ {
    "@value" : "NSMNTX"
  } ],
  "http://neo4j.org/vocab/sw#releaseDate" : [ {
    "@value" : "03-06-2019"
  } ],
  "http://neo4j.org/vocab/sw#runsOn" : [ {
    "@id" : "http://neo4j.org/ind#neo4j355"
  } ],
  "http://neo4j.org/vocab/sw#version" : [ {
    "@value" : "3.5.0.2"
  } ]
} ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run this cypher instead <code>MATCH (n:Resource)-[r]-(m) RETURN *</code> and you&#8217;ll be returning the whole dataset, or in other words, regenerating from Neo4j exactly the same RDF that we ingested in the first place.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_export_graph_ontology"><a class="link" href="#_export_graph_ontology">Export Graph Ontology</a></h3>
<div class="paragraph">
<p>It is possible to export your Graph schema in the form of an OWL Ontology. The same output produced by the <code>db.schema()</code> procedure can be generated as RDF/OWL through the <code>/onto</code> method.</p>
</div>
<div class="sect3">
<h4 id="_rdf_onto"><a class="link" href="#_rdf_onto">/rdf/onto</a></h4>
<div class="paragraph">
<p>The <code>/onto</code> method will run <code>db.schema()</code> on your Neo4j graph and will generate <code>owl:Class</code> definitions for each label found, and <code>owl:ObjectProperty</code> definitions for each relationship along with <code>rdfs:domain</code> and <code>rdfs:range</code> based on the labels of their start and end nodes. Here&#8217;s an example of the output for the Neo4j Movie database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/onto</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">http://localhost:7474/rdf/onto</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the ontology generated would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix neovoc: &lt;neo4j://vocabulary#&gt; .
@prefix neoind: &lt;neo4j://individuals#&gt; .


neovoc:Movie a owl:Class;
  rdfs:label "Movie" .

neovoc:Person a owl:Class;
  rdfs:label "Person" .

neovoc:ACTED_IN a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Movie .

neovoc:REVIEWED a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Movie .

neovoc:PRODUCED a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Movie .

neovoc:WROTE a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Movie .

neovoc:FOLLOWS a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Person .

neovoc:DIRECTED a owl:ObjectProperty;
  rdfs:domain neovoc:Person;
  rdfs:range neovoc:Movie .</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to set the serialisation format using the <code>accept</code> header param or the <code>format</code> request param. The following request would serialise the ontology as N-Triples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">:GET /rdf/onto?format=N-Triples</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rdf_ontonrdf"><a class="link" href="#_rdf_ontonrdf">/rdf/ontonrdf</a></h4>
<div class="paragraph">
<p>Similarly, if the Neo4j graph is the result of importing RDF via <code>n10s.importRDF</code>, the Ontology can be exported by running <code>ontonrdf</code>, which will take care of expanding the namespaces shortened in the import process.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:GET /rdf/ontonrdf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which applied to the example dataset about neo4j plugins used in section <a href="#Import">Importing RDF data</a>, would produce the following ontology:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix neovoc: &lt;neo4j://vocabulary#&gt; .
@prefix neoind: &lt;neo4j://individuals#&gt; .


&lt;http://neo4j.org/vocab/sw#GraphPlatform&gt; a owl:Class;
  rdfs:label "GraphPlatform" .

&lt;http://neo4j.org/vocab/sw#Neo4jPlugin&gt; a owl:Class;
  rdfs:label "Neo4jPlugin" .

&lt;http://neo4j.org/vocab/sw#AwesomePlatform&gt; a owl:Class;
  rdfs:label "AwesomePlatform" .

&lt;http://neo4j.org/vocab/sw#runsOn&gt; a owl:ObjectProperty;
  rdfs:domain &lt;http://neo4j.org/vocab/sw#Neo4jPlugin&gt;;
  rdfs:label "runsOn";
  rdfs:range &lt;http://neo4j.org/vocab/sw#AwesomePlatform&gt;, &lt;http://neo4j.org/vocab/sw#GraphPlatform&gt; .</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Mapping"><a class="link" href="#Mapping">Mapping graph models</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mappings can be used for applying transformations to the RDF as it&#8217;s imported into Neo4j and they can also be used to transform the vocabulary used in a Neo4j graph as it&#8217;s exported through the different RDF export methods described in <a href="#Export">Exporting RDF data</a>.
Mappings are based on terminology but they will not modify the structure of the graph. In other words, as we will see in this section, you will be able to use them to rename a property, a relationship or a label but not to change a property into a relationship.</p>
</div>
<div class="sect2">
<h3 id="_public_vocabularies_ontologies"><a class="link" href="#_public_vocabularies_ontologies">Public Vocabularies/Ontologies</a></h3>
<div class="paragraph">
<p>A public graph model is also called an Ontology (or a schema, or a vocabulary). We will not go into the details of the subtle differences between each flavour in this manual. All we need to know is that a graph model normally defines a set of terms (categories, properties, relationships&#8230;&#8203;) and how they relate to each other. Some common examples are <a href="https://schema.org/">schema.org</a>, <a href="https://edmcouncil.org/page/aboutfiboreview">FIBO</a> or the <a href="http://geneontology.org/">Gene Ontology</a>. Public vocabularies like the ones mentioned, typically uniquely identify the terms in it by using namespaces, so roughly speaking, a namespace identifies a vocabulary (or at least a portion of it).</p>
</div>
<div class="paragraph">
<p>To create a mapping with NSMNTX we need to do two things: first, create a reference to a public schema, and then use that reference to create individual mappings from elements in the Neo4j schema to elements in the public schema. Here&#8217;s how to do it:</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_mappings"><a class="link" href="#_defining_mappings">Defining mappings</a></h3>
<div class="paragraph">
<p>Let&#8217;s say we want to map our movie database schema to the public schema.org vocabulary.
First we&#8217;ll create a reference to the schema.org vocabulary passing the base URI and a prefix to be used in the RDF serialisation. You can use standard ones or a random accronym. Just make sure they&#8217;re both unique in your mapping definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.addSchema("http://schema.org/","sch")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to create a reference to a public vocabulary will produce as output, the newly created reference, or alternatively an error message indicating what went wrong:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒════════╤════════════════════╕
│"prefix"│"namespace"         │
╞════════╪════════════════════╡
│"sch"   │"http://schema.org/"│
└────────┴────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can create as many references to public vocabularies as needed, and there is also useful method (<code>mapping.addCommonSchemas</code>) that can be used to include a set of the most common schemas in one go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.addCommonSchemas()</code></pre>
</div>
</div>
<div class="paragraph">
<p>References to schemas can be removed using the <code>mapping.dropSchema</code> method and passing as single parameter the exact URI of the vocabulary we want to have deleted. Notice that this will remove both the schema and all element mappings defined on it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.dropSchema("http://purl.org/dc/elements/1.1/")</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we can list the currently existing schemas by running <code>mapping.listSchemas</code>. This method takes an optional string parameter that can be used to filter the list to the ones that match a particular search string in the schema uri or in the prefix. If we run the following after running the <code>mapping.addCommonSchemas</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.listSchemas("rdf")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We would get the following results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒════════╤═════════════════════════════════════════════╕
│"prefix"│"namespace"                                  │
╞════════╪═════════════════════════════════════════════╡
│"rdfs"  │"http://www.w3.org/2000/01/rdf-schema#"      │
├────────┼─────────────────────────────────────────────┤
│"rdf"   │"http://www.w3.org/1999/02/22-rdf-syntax-ns#"│
└────────┴─────────────────────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we have defined a reference to a public vocabulary/schema, we can now create actual mappings for elements in our graph to elements in the public schemas. The <code>mapping.addMappingToSchema</code> procedure. This method takes three parameters, the URI of a public schema previously added via <code>mapping.addSchema</code> and a pair formed by the name of the element in our graph (a property name, a label or a relationship type) and the matching element in the public schema.</p>
</div>
<div class="paragraph">
<p>The following example shows how to define a map from a <code>CHILD_CATEGORY</code> relationship type in a Neo4j graph to the <code>skos:narrower</code> relationship (or ObjectProperty in RDF terminology).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.addMappingToSchema("http://www.w3.org/2004/02/skos/core#", "CHILD_CATEGORY", "narrower")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like we did with schema references, we can list existing mappings using <code>mapping.listMappings</code> and filter the list with an optional search string parameter to return only mappings where either the graph element name or the schema element name match the search string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.listMappings()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Producing a listing with the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════════════════════════════════╤══════════════╤═══════════════╤════════════════╕
│"schemaNs"                            │"schemaPrefix"│"schemaElement"│"elemName"      │
╞══════════════════════════════════════╪══════════════╪═══════════════╪════════════════╡
│"http://www.w3.org/2004/02/skos/core#"│"skos"        │"narrower"     │"CHILD_CATEGORY"│
└──────────────────────────────────────┴──────────────┴───────────────┴────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to remove individual ones with <code>mapping.dropMapping</code> passing as single parameter the name of the graph model element on which the mapping is defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.dropMapping("CHILD_CATEGORY")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mappings_for_export"><a class="link" href="#_mappings_for_export">Mappings for export</a></h3>
<div class="paragraph">
<p>Let&#8217;s look at the case where we want to publish a graph in Neo4j but we want to map it to our organisation&#8217;s canonical model, our Enterprise Ontology or any public vocabulary. For this example we&#8217;re going to use the Northwind database in Neo4j <code>:play northwind-graph</code> and the public <a href="https://schema.org/">schema.org</a> vocabulary.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the script that defines the reference to the <code>schema.org</code> public vocabulary and a few individual mappings for elements in the Northwind database in Neo4j.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">//set parameter uri -&gt;   :param uri: "http://schema.org/"

CALL n10s.mapping.addSchema($uri,"sch");
CALL n10s.mapping.addMappingToSchema($uri,"Order","Order");
CALL n10s.mapping.addMappingToSchema($uri,"orderID","orderNumber");
CALL n10s.mapping.addMappingToSchema($uri,"orderDate","orderDate");

CALL n10s.mapping.addMappingToSchema($uri,"ORDERS","orderedItem");

CALL n10s.mapping.addMappingToSchema($uri,"Product","Product");
CALL n10s.mapping.addMappingToSchema($uri,"productID","productID");
CALL n10s.mapping.addMappingToSchema($uri,"productName","name");

CALL n10s.mapping.addMappingToSchema($uri,"PART_OF","category");

CALL n10s.mapping.addMappingToSchema($uri,"categoryName","name");</code></pre>
</div>
</div>
<div class="paragraph">
<p>After running the previous script, we can check that the mappings have been correctly defined with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">call n10s.mapping.listMappings()</code></pre>
</div>
</div>
<div class="paragraph">
<p>That should return:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒════════════════════╤══════════════╤═══════════════╤══════════════╕
│"schemaNs"          │"schemaPrefix"│"schemaElement"│"elemName"    │
╞════════════════════╪══════════════╪═══════════════╪══════════════╡
│"http://schema.org/"│"sch"         │"Order"        │"Order"       │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"orderNumber"  │"orderID"     │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"orderDate"    │"orderDate"   │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"orderedItem"  │"ORDERS"      │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"Product"      │"Product"     │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"productID"    │"productID"   │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"name"         │"productName" │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"category"     │"PART_OF"     │
├────────────────────┼──────────────┼───────────────┼──────────────┤
│"http://schema.org/"│"sch"         │"name"         │"categoryName"│
└────────────────────┴──────────────┴───────────────┴──────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can see these mappings in action by running any of the RDF generating methods described in <a href="#Export">Exporting RDF data</a> (<code>/describe/id</code>, <code>/describe/find/</code> or <code>/cypher</code>). Let&#8217;s use the <code>/cypher</code> method to serialise as RDF an order given its <code>orderID</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:POST /rdf/cypher
{ "cypher" : "MATCH path = (n:Order { orderID : '10785'})-[:ORDERS]-&gt;()-[:PART_OF]-&gt;(:Category { categoryName : 'Beverages'}) RETURN path " , "format": "RDF/XML" , "mappedElemsOnly" : true }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Cypher query uses the elements in the Neo4j graph but the generated RDF uses schema.org vocabulary elements. The mapping we just defined is bridging the two. Note that the mapping is completely dynamic which means that any change to the mapping definition will be applied to any subsequent request.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Elements for which no mapping has been defined will use the default Neo4j schema but we can specify that only mapped elements are to be exported by setting the <code>mappedElemsOnly</code> parameter to <code>true</code> in the request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s the output generated by the previous request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF
	xmlns:neovoc="neo4j://com.neo4j/voc#"
	xmlns:neoind="neo4j://com.neo4j/indiv#"
	xmlns:sch="http://schema.org/"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

&lt;rdf:Description rdf:about="neo4j://com.neo4j/indiv#786"&gt;
	&lt;rdf:type rdf:resource="http://schema.org/Order"/&gt;
	&lt;sch:orderNumber&gt;10785&lt;/sch:orderNumber&gt;
	&lt;sch:orderDate&gt;1997-12-18 00:00:00.000&lt;/sch:orderDate&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://com.neo4j/indiv#74"&gt;
	&lt;rdf:type rdf:resource="http://schema.org/Product"/&gt;
	&lt;sch:productID&gt;75&lt;/sch:productID&gt;
	&lt;sch:name&gt;Rhönbräu Klosterbier&lt;/sch:name&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://com.neo4j/indiv#80"&gt;
	&lt;sch:name&gt;Beverages&lt;/sch:name&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://com.neo4j/indiv#786"&gt;
	&lt;sch:orderedItem rdf:resource="neo4j://com.neo4j/indiv#74"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="neo4j://com.neo4j/indiv#74"&gt;
	&lt;sch:category rdf:resource="neo4j://com.neo4j/indiv#80"/&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s another example of use of mappings for export in <a href="https://jbarrasa.com/2018/10/18/quickgraph7-creating-a-schema-org-linked-data-endpoint-on-neo4j-in/">this blog post</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mappings_for_import"><a class="link" href="#_mappings_for_import">Mappings for import</a></h3>
<div class="paragraph">
<p>In this section we&#8217;ll see how to use mappings to apply changes to an RDF dataset on ingestion using the RDF import procedures described in <a href="#Import">Importing RDF data</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say we are importing into Neo4j the <a href="https://permid.org/download">the Open PermID dataset</a> from Thomson Reuters. Here is a small fragment of the 'Person' file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">@prefix vcard: &lt;http://www.w3.org/2006/vcard/ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix permid: &lt;https://permid.org/&gt; .

permid:1-34419230351
  a vcard:Person ;
  vcard:given-name "Keith"^^xsd:string .

permid:1-34419198943
  vcard:family-name "Peltz"^^xsd:string ;
  vcard:given-name "Maxwell"^^xsd:string ;
  vcard:additional-name "S"^^xsd:string ;
  a vcard:Person .

permid:1-34418273443
  vcard:family-name "Benner"^^xsd:string ;
  vcard:given-name "Thomas"^^xsd:string ;
  a vcard:Person ;
  vcard:friend-of &lt;https://permid.org/1-34419230351&gt; .</code></pre>
</div>
</div>
<div class="paragraph">
<p>As part of the import process, we want to drop the namespaces (as described in <a href="#Import">Importing RDF data</a>, this can be done using the <code>handleVocabUris: "IGNORE"</code> configuration) <strong>BUT</strong> in this case, we also want to create more neo4j-friendly names for properties. We want to get rid of the dashes in property names like <code>given-name</code> or <code>additional-name</code> and use 'camelCase' notation instead. The way to tell NSMNTX to do that is by defining a model mapping and setting the <code>handleVocabUris</code> parameter on import to <code>'MAP'</code>.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start by defining a mapping like the one we defined for exporting RDF. Note that the properties we want to map are all in the same <code>vcard</code> vocabulary: <code><a href="http://www.w3.org/2006/vcard/ns#" class="bare">http://www.w3.org/2006/vcard/ns#</a></code>.  The following script should do the job:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">WITH
[{ neoSchemaElem : "givenName", publicSchemaElem:	"given-name" },
{ neoSchemaElem : "familyName", publicSchemaElem: "family-name" },
{ neoSchemaElem : "additionalName", publicSchemaElem: "additional-name" },
{ neoSchemaElem : "FRIEND_OF", publicSchemaElem: "friend-of" }] AS mappings,
"http://www.w3.org/2006/vcard/ns#" AS vcardUri

CALL n10s.mapping.addSchema(vcardUri,"vcard") YIELD namespace
UNWIND mappings as m
CALL n10s.mapping.addMappingToSchema(vcardUri,m.neoSchemaElem,m.publicSchemaElem) YIELD schemaElement
RETURN count(schemaElement) AS mappingsDefined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like we did in the previous section, we define a vocabulary with <code>mapping.addSchema</code> and then we add individual mappings for elements in the vocabulary with <code>mapping.addMappingToSchema</code>. If there were multiple vocabularies to map, we would just need repeat the process for each of them.</p>
</div>
<div class="paragraph">
<p>Now we can check that the mappings are correctly defined by running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.mapping.listMappings()</code></pre>
</div>
</div>
<div class="paragraph">
<p>which produces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════════════════════════════╤══════════════╤═════════════════╤════════════════╕
│"schemaNs"                        │"schemaPrefix"│"schemaElement"  │"elemName"      │
╞══════════════════════════════════╪══════════════╪═════════════════╪════════════════╡
│"http://www.w3.org/2006/vcard/ns#"│"vcard"       │"given-name"     │"givenName"     │
├──────────────────────────────────┼──────────────┼─────────────────┼────────────────┤
│"http://www.w3.org/2006/vcard/ns#"│"vcard"       │"family-name"    │"familyName"    │
├──────────────────────────────────┼──────────────┼─────────────────┼────────────────┤
│"http://www.w3.org/2006/vcard/ns#"│"vcard"       │"additional-name"│"additionalName"│
├──────────────────────────────────┼──────────────┼─────────────────┼────────────────┤
│"http://www.w3.org/2006/vcard/ns#"│"vcard"       │"friend-of"      │"FRIEND_OF"     │
└──────────────────────────────────┴──────────────┴─────────────────┴────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Important to note that when using the option <code>handleVocabUris: "MAP"</code>, all non-mapped vocabulary elements will get the default treatment they get when the <code>'IGNORE'</code> option is selected.</p>
</div>
<div class="paragraph">
<p>Once the mappings are defined, we can run the import process as described in <a href="#Import">Importing RDF data</a> with the mentioned config param <code>handleVocabUris: 'MAP'</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.previewRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/permid-person-fragment.ttl","Turtle", { handleVocabUris: 'MAP' })</code></pre>
</div>
</div>
<div class="paragraph">
<p>After data load, we will be able to query the imported graph with a much more friendly cypher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (n:Person) RETURN n.uri AS uri, n.familyName as familyName LIMIT 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>to get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════════════════════════════╤══════════════╕
│"uri"                             │"familyName"  │
╞══════════════════════════════════╪══════════════╡
│"https://permid.org/1-34419230351"│null          │
├──────────────────────────────────┼──────────────┤
│"https://permid.org/1-34418273443"│"Benner"      │
├──────────────────────────────────┼──────────────┤
│"https://permid.org/1-34419198943"│"Peltz"       │
└──────────────────────────────────┴──────────────┘</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The combination of a mapping definition plus the use of the <code>handleVocabUris: 'MAP'</code> configuration can be applied not only to the <code>n10s.importRDF</code> procedure but also to the preview ones <code>n10s.previewRDF</code> and <code>n10s.previewRDFSnippet</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Inference"><a class="link" href="#Inference">Inferencing/Reasoning</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>By inferencing/reasoning we understand the process of getting information from the Neo4j database
that is not explicitly stored. Here is a simple example: you have in your Neo4j graph some nodes labeled as
loans and some nodes labeled as mortgages. If you manage to express the fact that a
mortgage is a type of loan and consequently nodes labeled as mortgages are loans too, then you could expect
your smart Neo4j DB to apply this reasoning on the fly and return both
loan and mortgage nodes when you query for loans (even though you never explicitly labeled mortgage nodes
as loans).</p>
</div>
<div class="paragraph">
<p>This kind of reasoning/inferencing is what this set of procedures will help you with.</p>
</div>
<div class="sect2">
<h3 id="_hierarchies_of_categories"><a class="link" href="#_hierarchies_of_categories">Hierarchies of Categories</a></h3>
<div class="paragraph">
<p>To model a hierarchy of categories we&#8217;ll typically use nodes in the graph to represent the categories and
related nodes connected through <code>SUBCAT_OF</code> or <code>NARROWER_THAN</code> relationships (or whatever your
choice of terminology will be).</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a set of categories from <a href="http://id.loc.gov/authorities/subjects.html">the Library of Congress Subject Headings</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CREATE (c:LCSHTopic { authoritativeLabel: "Crystallography", dbLabel: "Crystallography", identifier: "sh 85034498" })
CREATE (po:LCSHTopic { authoritativeLabel: "Physical optics", dbLabel: "PhysicalOptics", identifier: "sh 85095187" })
CREATE (s:LCSHTopic { authoritativeLabel: "Solids", dbLabel: "Solids", identifier: "sh 85124647" })
CREATE (c)&lt;-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Crystal optics", dbLabel: "CrystalOptics", identifier: "sh 85034488" })-[:NARROWER_THAN]-&gt;(po)
CREATE (c)&lt;-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Crystals", dbLabel: "Crystals", identifier: "sh 85034503" })-[:NARROWER_THAN]-&gt;(s)
CREATE (c)&lt;-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Dimorphism (Crystallography)", dbLabel: "DimorphismCrystallography", identifier: "sh 2007001101" })
CREATE (c)&lt;-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Isomorphism (Crystallography)", dbLabel: "IsomorphismCrystallography", identifier: "sh 85068653" })</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we use LCSHTopic to label the categories and the <code>NARROWER_THAN</code> to link them in a
hierarchy that as we can see in this fragment does not necessarily need to be a tree (it the general
case it will be a graph).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/crystallography-hierarchy.png" alt="Topic hierarchy from the LCSH">
</div>
</div>
<div class="paragraph">
<p>We have defined a hierarchy of categories and now we&#8217;ll want to annotate individuals with the categories defined.
To do this we have two main options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We can use labels to tag a node representing an individual with the category it belongs to.
While this approach is preferable in many cases, it will be harder to navigate to nodes with related
labels (by related in this case I mean super or sublabels).</p>
</li>
<li>
<p>We can link nodes representing individuals to the category (or categories) they belong to using
a <code>TYPE</code> or <code>IN_CATEGORY</code> (or again whatever your preferred name for that relationship).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following methods will help you leveraging explicit class hierarchies in your graph to run
inferences whatever the modeling approach you follow from the ones described before.</p>
</div>
<div class="sect3">
<h4 id="_semantics_inference_nodeslabelled"><a class="link" href="#_semantics_inference_nodeslabelled">n10s.inference.nodesLabelled</a></h4>
<div class="paragraph">
<p>Let&#8217;s look at the first way of annotating individuals. This script creates a few publications (books) from the
<a href="https://bnb.data.bl.uk/">British National Library catalog</a> sets a label
on each of them. The labels match categories defined before.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CREATE (:Book:CrystalOptics { title: "Crystals and light", identifier: "2167673"})
CREATE (:Book:CrystalOptics { title: "Optical crystallography", identifier: "11916857"})

CREATE (:Book:IsomorphismCrystallography { title: "Isomorphism in minerals", identifier: "8096161"})

CREATE (:Book:Crystals { title: "Crystals and life", identifier: "12873809"})
CREATE (:Book:Crystals { title: "Highlights in applied mineralogy", identifier: "20234576"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in this case there is no relationship connecting the books with the category they belong to.
We are using labels instead. But there is an explicit hierarchy for these labels that we want to exploit.</p>
</div>
<div class="paragraph">
<p>What we want now is to be able to ask Neo4j for all the books on Crystallography and get all those
actually labelled as Crystallography but also all those labelled as any of Crystallography&#8217;s subcategories.
That&#8217;s exactly what the <code>n10s.inference.nodesLabelled</code> does for us. All we need to do is pass
the details on how is the category hierarchy built: <code>catLabel</code> will contain the label used to describe
categories (the default is <code>Label</code>) which in our case is <code>LCSHTopic</code>. We&#8217;ll also need to specify in the
 <code>subCatRel</code> parameter, the relationship used to define the hierarchy (the default is <code>SLO</code> for
 Sub Label Of) which in our case is <code>NARROWER_THAN</code>. Finally, we need to specify the name in the
 category node containing the label name (the default is <code>name</code>) which in our example is <code>dbLabel</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.inference.nodesLabelled('Crystallography',  { catNameProp: "dbLabel", catLabel: "LCSHTopic", subCatRel: "NARROWER_THAN" }) YIELD node
RETURN node.identifier as id, node.title as title, labels(node) as categories</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run this query, and even thoug not a single node in our graph is actually labelled as <code>Crystallography</code>,
we get the following results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════╤══════════════════════════════════╤═════════════════════════════════════╕
│"id"      │"title"                           │"categories"                         │
╞══════════╪══════════════════════════════════╪═════════════════════════════════════╡
│"2167673" │"Crystals and light"              │["CrystalOptics","Book"]             │
├──────────┼──────────────────────────────────┼─────────────────────────────────────┤
│"11916857"│"Optical crystallography"         │["CrystalOptics","Book"]             │
├──────────┼──────────────────────────────────┼─────────────────────────────────────┤
│"12873809"│"Crystals and life"               │["Crystals","Book"]                  │
├──────────┼──────────────────────────────────┼─────────────────────────────────────┤
│"20234576"│"Highlights in applied mineralogy"│["Crystals","Book"]                  │
├──────────┼──────────────────────────────────┼─────────────────────────────────────┤
│"8096161" │"Isomorphism in minerals"         │["IsomorphismCrystallography","Book"]│
└──────────┴──────────────────────────────────┴─────────────────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semantics_inference_haslabel"><a class="link" href="#_semantics_inference_haslabel">n10s.inference.hasLabel</a></h4>
<div class="paragraph">
<p>If what we are looking for is not an set of nodes in a given category but rather a predicate telling us
whether a node is or not is in a category then the function we need is <code>n10s.inference.hasLabel</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a user with interests in some of the books in our database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MERGE (jb:User { userId : "JB2020"}) with jb
MATCH (book1:Book { identifier : "20234576" })
MATCH (book2:Book { identifier : "11916857" })
WITH jb, book1, book2
CREATE (book1)&lt;-[:INTERESTED_IN]-(jb)-[:INTERESTED_IN]-&gt;(book2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can query for the books about <code>Physical optics</code> that he&#8217;s interested in. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (:User { userId : "JB2020"})-[:INTERESTED_IN]-&gt;(b:Book)
WHERE n10s.inference.hasLabel(b,'PhysicalOptics',$inferenceParams)
RETURN b.identifier as id, b.title as title, labels(b) as categories</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that now we&#8217;re passing the function configuration as a parameter. So we&#8217;ll have to set the param
value upfront if we&#8217;re using the Neo4j browser.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:param inferenceParams: { catNameProp: "dbLabel", catLabel: "LCSHTopic", subCatRel: "NARROWER_THAN" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And again, even though there&#8217;s no book explicitly labelled as 'PhysicalOptics', the query will
produce the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════╤═════════════════════════╤════════════════════════╕
│"id"      │"title"                  │"categories"            │
╞══════════╪═════════════════════════╪════════════════════════╡
│"11916857"│"Optical crystallography"│["CrystalOptics","Book"]│
└──────────┴─────────────────────────┴────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semantics_inference_nodesincategory"><a class="link" href="#_semantics_inference_nodesincategory">n10s.inference.nodesInCategory</a></h4>
<div class="paragraph">
<p>Now let&#8217;s look at the second way of annotating individuals.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If you were running the previous
example delete all Book nodes before continuing with this second approach.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This script creates a few of them and links them to the categories defined before.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (co:LCSHTopic { authoritativeLabel: "Crystal optics"})
MATCH (is:LCSHTopic { authoritativeLabel: "Isomorphism (Crystallography)"})
MATCH (cr:LCSHTopic { authoritativeLabel: "Crystals"})

CREATE (:Work { title: "Crystals and light", identifier: "2167673"})-[:HAS_SUBJECT]-&gt;(co)
CREATE (:Work { title: "Optical crystallography", identifier: "11916857"})-[:HAS_SUBJECT]-&gt;(co)

CREATE (:Work { title: "Isomorphism in minerals", identifier: "8096161"})-[:HAS_SUBJECT]-&gt;(is)

CREATE (:Work { title: "Crystals and life", identifier: "12873809"})-[:HAS_SUBJECT]-&gt;(cr)
CREATE (:Work { title: "Highlights in applied mineralogy", identifier: "20234576"})-[:HAS_SUBJECT]-&gt;(cr)</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/crystallography-with-instances.png" alt="Topic hierarchy with instances">
</div>
</div>
<div class="paragraph">
<p>In this case, the query to get the nodes in a particular category will make use of
 the <code>n10s.inference.nodesInCategory</code> procedure. This procedure takes as
 parameters, the details of how is the category hierarchy built and how are individuals connected to
 the categories: <code>inCatRel</code> specifies the relationship used to link an instance to a category (the
 default is <code>IN_CAT</code>) which in our example is <code>HAS_SUBJECT</code>. <code>subCatRel</code> specifies the relationship used
 to define the hierarchy (the default is <code>SCO</code> for Sub Category Of) which in our example is <code>NARROWER_THAN</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (cat:LCSHTopic { authoritativeLabel: "Crystallography"})
CALL n10s.inference.nodesInCategory(cat, { inCatRel: "HAS_SUBJECT", subCatRel: "NARROWER_THAN"}) yield node
return node.title as work</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run this Cypher fragment, we get the following list of results, even though not a single node
in the graph is actually explicitly connected to the <code>Crystallography</code> category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════════════════════════════╕
│"work"                            │
╞══════════════════════════════════╡
│"Optical crystallography"         │
├──────────────────────────────────┤
│"Crystals and light"              │
├──────────────────────────────────┤
│"Isomorphism in minerals"         │
├──────────────────────────────────┤
│"Crystals and life"               │
├──────────────────────────────────┤
│"Highlights in applied mineralogy"│
└──────────────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semantics_inference_incategory_node_category"><a class="link" href="#_semantics_inference_incategory_node_category">n10s.inference.inCategory(node,
  category, {})</a></h4>
<div class="paragraph">
<p>If what we are looking for is not an set of nodes in a given category but rather a predicate telling us
whether a node is or not is in a category then the function we need is <code>n10s.inference.inCategory</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a user with interests in some of the books in our database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MERGE (jb:User { userId : "JB2020"}) with jb
MATCH (book1:Work { identifier : "20234576" })
MATCH (book2:Work { identifier : "11916857" })
WITH jb, book1, book2
CREATE (book1)&lt;-[:INTERESTED_IN]-(jb)-[:INTERESTED_IN]-&gt;(book2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can query for the books about <code>Physical optics</code> that he&#8217;s interested in. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (phyOpt:LCSHTopic { authoritativeLabel: "Physical optics"})
MATCH (:User { userId : "JB2020"})-[:INTERESTED_IN]-&gt;(b:Work)
WHERE n10s.inference.inCategory(b,phyOpt,$inferenceParams)
RETURN b.identifier as id, b.title as title</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that now we&#8217;re passing the function configuration as a parameter. So we&#8217;ll have to set the param
value upfront if we&#8217;re using the Neo4j browser.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">:param inferenceParams: { inCatRel: "HAS_SUBJECT", subCatRel: "NARROWER_THAN"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And again, even though there&#8217;s no book explicitly connected to the 'PhysicalOptics' category, the query will
produce the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════╤═════════════════════════╕
│"id"      │"title"                  │
╞══════════╪═════════════════════════╡
│"11916857"│"Optical crystallography"│
└──────────┴─────────────────────────┘</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_real_world_example"><a class="link" href="#_a_real_world_example">A real  world example</a></h4>
<div class="paragraph">
<p>We can use the <code>n10s.importOntology</code> procedure to import <a href="http://www.obofoundry.org/ontology/ncbitaxon.html">the NCBI Taxon ontology</a>.
This is an ontology representation of the National Center for Biotechnology Information (NCBI) organismal taxonomy.
It contains 1.8 million classes (<code>Class</code>) and 3.6 million subClass of (<code>SCO</code>) relationships.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.importOntology("http://purl.obolibrary.org/obo/ncbitaxon.owl","RDF/XML")</code></pre>
</div>
</div>
<div class="paragraph">
<p>It takes just over a couple of minutes to load it into Neo4j.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒═══════════════════╤═══════════════╤═══════════════╤════════════╤═══════════╤═══════════════╕
│"terminationStatus"│"triplesLoaded"│"triplesParsed"│"namespaces"│"extraInfo"│"configSummary"│
╞═══════════════════╪═══════════════╪═══════════════╪════════════╪═══════════╪═══════════════╡
│"OK"               │5480841        │12581469       │null        │""         │{}             │
└───────────────────┴───────────────┴───────────────┴────────────┴───────────┴───────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s add to the hierarchy a few individuals. Some dogs (<code>NCBITaxon_9615</code>, <em>"Canis lupus familiaris"</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CREATE (p:Person { name: "Mr. Doglover"}) WITH p
UNWIND [ { name: "Perdita" , dob: "30/11/2016"}, { name: "Toby" , dob: "14/03/2019"}, { name: "Lucky" , dob: "14/11/2018"}, { name: "Pongo" , dob: "4/10/2012"}] as doggy
CREATE (:Pet:NCBITaxon_9615 { name: doggy.name, dob: doggy.dob })-[:OWNER]-&gt;(p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And why not? some mice (<code>NCBITaxon_10092</code>, <em>"Mus musculus domesticus"</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CREATE (p:Person { name: "Mr. Mouselover"}) WITH p
UNWIND [ { name: "Mickey" , dob: "30/11/2016"}, { name: "Minnie" , dob: "14/03/2019"}, { name: "Topo" , dob: "14/11/2018"}, { name: "Rastamouse" , dob: "4/10/2012"}] as mouse
CREATE (:Pet:NCBITaxon_10092 { name: mouse.name, dob: mouse.dob })-[:OWNER]-&gt;(p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we&#8217;re looking for instances of mammals in our database, we&#8217;d look for nodes labelled as <code>NCBITaxon_40674</code>
(<em>"Mammalia"</em>). Obviously no node has been labelled as mammal, but we expect NSMNTX to do the job for us.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.inference.nodesLabelled('NCBITaxon_40674',{ catLabel: "Class", subCatRel: "SCO" }) YIELD node
RETURN node.name as name, node.dob as dob, labels(node)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only a few milliseconds needed to identify them in the nearly 11k categories under <em>Mammalia</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒════════════╤════════════╤═════════════════════════╕
│"name"      │"dob"       │"labels(node)"           │
╞════════════╪════════════╪═════════════════════════╡
│"Mickey"    │"30/11/2016"│["Pet","NCBITaxon_10092"]│
├────────────┼────────────┼─────────────────────────┤
│"Minnie"    │"14/03/2019"│["Pet","NCBITaxon_10092"]│
├────────────┼────────────┼─────────────────────────┤
│"Topo"      │"14/11/2018"│["Pet","NCBITaxon_10092"]│
├────────────┼────────────┼─────────────────────────┤
│"Rastamouse"│"4/10/2012" │["Pet","NCBITaxon_10092"]│
├────────────┼────────────┼─────────────────────────┤
│"Perdita"   │"30/11/2016"│["NCBITaxon_9615","Pet"] │
├────────────┼────────────┼─────────────────────────┤
│"Toby"      │"14/03/2019"│["NCBITaxon_9615","Pet"] │
├────────────┼────────────┼─────────────────────────┤
│"Lucky"     │"14/11/2018"│["NCBITaxon_9615","Pet"] │
├────────────┼────────────┼─────────────────────────┤
│"Pongo"     │"4/10/2012" │["NCBITaxon_9615","Pet"] │
└────────────┴────────────┴─────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interestingly, and because Neo4j is a native Graph DB implementing index free adjacency, if we were
to search across the 1.2 million categories for all instances of <em>"Eukaryota"</em> (<code>NCBITaxon_2759</code>),
(one of the top three categories that all cellular organisms are divided into) it would take NSMNTX
exactly the same time to identify them. Here&#8217;s the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.inference.nodesLabelled('NCBITaxon_2759',{ catLabel: "Class", subCatRel: "SCO" }) YIELD node
RETURN node.name as name, node.dob as dob, labels(node)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, we can verify in milliseconds how many of an individual&#8217;s pets are actually instances of
<em>"Eukaryota"</em>. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH path = (:Person { name : "Mr. Doglover"})&lt;-[:OWNER]-(pet)
WHERE n10s.inference.hasLabel(pet,'NCBITaxon_2759',$inferenceParams)
RETURN count(pet)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hierarchies_of_relationships"><a class="link" href="#_hierarchies_of_relationships">Hierarchies of Relationships</a></h3>
<div class="paragraph">
<p>Just like we did with categories, we can use <code>rdfs:subPropertyOf</code> to create hierarchies of relationships,
or in other words to state that all resources connected by one relationship are also implicitly connected
by any parent relationship. If We state that <code>ACTED_IN</code> is a subproperty of <code>WORKED_IN</code>,
when we find in the graph that Keanu Reeves <code>ACTED_IN</code> The Matrix, we can safely derive the fact that he
also <code>WORKED_IN</code> that movie, even if there is not an explicit <code>WORKED_IN</code> relationship in the graph
between Keanu and The Matrix.
This is useful in situations where we want to be able to dynamically define relationships by composing
existing ones.</p>
</div>
<div class="paragraph">
<p>The <code>n10s.inference.getRels</code> stored procedure uses exactly these n10s to infer implicit
relationships between nodes in the graph.</p>
</div>
<div class="sect3">
<h4 id="_semantics_inference_getrels"><a class="link" href="#_semantics_inference_getrels">n10s.inference.getRels</a></h4>
<div class="paragraph">
<p>Let&#8217;s take the movie database. Remember you can have it loaded in Neo4j by running <code>:play movies</code> and
following the instructions in the guide.
Let&#8217;s say we have <a href="http://jbarrasa.github.io/neosemantics/docs/rdf/movieDBRelHierarchy.ttl">a fragment
of a movie ontology</a> that contains a definition
of a relationship hierarchy. It does it by defining a number of <code>rdfs:subPropertyOf</code> statements
between relationships.
For instance, it states that every <code>ACTED_IN</code> relationship is also a <code>WORKED_IN</code> one. This is
the triple in question:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-RDF" data-lang="RDF">...

neovoc:ACTED_IN a owl:ObjectProperty;
  rdfs:label "ACTED_IN";
  rdfs:subPropertyOf neovoc:WORKED_IN .

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>To see this inferencing procedure in action, we&#8217;ll start by loading the ontology. We can do this
 by either using the <code>n10s.importOntology</code> or the <code>n10s.importRDF</code> methods described in
 the <a href="#Import">Importing RDF data</a> section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We can get a hierarchy from an ontology or we can create it with a cypher script from any other
source.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If  we run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">CALL n10s.importOntology("http://jbarrasa.github.io/neosemantics/docs/rdf/movieDBRelHierarchy.ttl", "Turtle")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We should get a simple hierarchy of properties like the one in this screen capture from the Neo4j
browser.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="docs/img/movieDB-PropertyHierarchy-OntoLoad.png" alt="property hierarchy in a possible Movie Database Ontology loaded into Neo4j">
</div>
</div>
<div class="paragraph">
<p>Writing a query that returns all nodes connected to the movie The Matrix through the 'virtual' <code>WORKED_IN</code> relationship
is an easy task with the <code>n10s.inference.getRels</code> procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">match (thematrix:Movie {title: "The Matrix"})
call n10s.inference.getRels(thematrix,"WORKED_IN", { subRelRel: "SPO" }) yield rel, node
return type(rel) as relType, node</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">╒══════════╤═════════════════════════════════════════╕
│"relType" │"node"                                   │
╞══════════╪═════════════════════════════════════════╡
│"ACTED_IN"│{"name":"Emil Eifrem","born":1978}       │
├──────────┼─────────────────────────────────────────┤
│"PRODUCED"│{"name":"Joel Silver","born":1952}       │
├──────────┼─────────────────────────────────────────┤
│"DIRECTED"│{"name":"Lana Wachowski","born":1965}    │
├──────────┼─────────────────────────────────────────┤
│"DIRECTED"│{"name":"Lilly Wachowski","born":1967}   │
├──────────┼─────────────────────────────────────────┤
│"ACTED_IN"│{"name":"Hugo Weaving","born":1960}      │
├──────────┼─────────────────────────────────────────┤
│"ACTED_IN"│{"name":"Laurence Fishburne","born":1961}│
├──────────┼─────────────────────────────────────────┤
│"ACTED_IN"│{"name":"Carrie-Anne Moss","born":1967}  │
├──────────┼─────────────────────────────────────────┤
│"ACTED_IN"│{"name":"Keanu Reeves","born":1964}      │
└──────────┴─────────────────────────────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s say we want to modify the meaning of the <code>WORKED_IN</code> relationship to exclude <code>PRODUCED</code> and
keep only <code>artistic involvement</code> connections, tis is <code>WROTE</code>, <code>ACTED_IN</code> and <code>DIRECTED</code>. We don&#8217;t need
to alter our database, just our ontology.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Cypher" data-lang="Cypher">MATCH (:Relationship {name:"PRODUCED"})-[r:SPO]-&gt;(:Relationship {name:"WORKED_IN"})
DELETE r</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run the same query again, we&#8217;ll get different results, this time excluding producers. Think
of this in a large scale DB. We can effectively modify relationships globally by adding or deleting
a simple link to the hierarchy and without having to modify every single instance.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Reference"><a class="link" href="#Reference">NSMNTX Reference</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Complete list of all available stored procedures, functions and extensions in NSMNTX.</p>
</div>
<div class="sect2">
<h3 id="_stored_procedures"><a class="link" href="#_stored_procedures">Stored Procedures</a></h3>
<div class="sect3">
<h4 id="_rdf_import"><a class="link" href="#_rdf_import">RDF Import</a></h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Procedure Name</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description and example usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.importRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fetches RDF from a url (file or http) and stores it in Neo4j as a property graph. This procedure requires and index on :Resource(uri)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.importRDFSnippet</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>string containing a valid RDF fragment</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Imports an RDF snippet passed as parameter and stores it in Neo4j as a property graph. Requires and index on :Resource(uri)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.importQuadRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: TriG,N-Quads)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">importRDF for RDF Quads</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.importOntology</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the <strong>ontology import</strong> table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Imports classes, properties (dataType and Object), hierarchies thereof and domain and range info.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.streamRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses RDF and streams each triple as a record with &lt;S,P,O&gt; along with datatype and language tag for Literal values. No writing to the DB. This SP is useful when you want to import into your Neo4j graph fragments of an RDF dataset in a custom way.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.previewRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses RDF and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB. Notice that this is adequate for a preliminary visual analysis of a SMALL dataset. Think how many nodes you want rendered in your browser.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.previewRDFSnippet</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>string containing a valid RDF fragment</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses an RDF fragment passed as parameter (no retrieval from url) and produces virtual Nodes and relationships for preview in the Neo4j browser. No writing to the DB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.deleteRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: Turtle, N-Triples, JSON-LD, TriG, RDF/XML)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deletes triples from Neo4j.
  Works on a graph resulted of importing RDF via n10s.importRDF(). Delete config must match the one
  used on import</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.deleteQuadRDF</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the dataset</p>
</li>
<li>
<p>serialization format (valid formats: TriG,N-Quads)</p>
</li>
<li>
<p>optional map with params from the table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deletes quads from Neo4j. Works
  on a graph resulted of importing RDF quads via n10s.importQuadRDF(). Delete config must match the
  one used on import</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_rdf_import_params"><a class="link" href="#_rdf_import_params">RDF Import Params</a></h5>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Param</th>
<th class="tableblock halign-left valign-top">values(default)</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">handleVocabUris</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'SHORTEN','IGNORE','MAP','KEEP' ('SHORTEN')</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>'SHORTEN', full uris are shortened using prefixes for property names, relationship names and labels</p>
</li>
<li>
<p>'IGNORE' uris are ignored and only local names are kept</p>
</li>
<li>
<p>'MAP' vocabulary element mappings are applied on import</p>
</li>
<li>
<p>'KEEP' uris are kept unchanged</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyNeo4jNaming</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean (false)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set to true and in combination with <code>handleVocabUris: 'IGNORE'</code>, Neo4j
capitalisation is applied to vocabulary elements (all caps for relationship types, capital first for labels, etc.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">handleMultival</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'OVERWRITE', 'ARRAY' ('OVERWRITE')</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>'OVERWRITE' property values are kept single valued. Multiple values in the imported RDF are overwriten (only the last one is kept)</p>
</li>
<li>
<p>'ARRAY' properties are stored in an array enabling storage of multiple values. All of them unless <code>multivalPropList</code> is set.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">multivalPropList</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list of strings ([])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of property names (full uri) to be stored as arrays. The rest are treated as 'OVERWRITE'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">keepLangTag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean (false)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set to true, the language tag is kept along with the property value. Useful for multilingual datasets.
Use helper function <code>getLangValue</code> to get specific values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">predicateExclusionList</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list of strings ([])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List  of predicates (full uri) that are to be ignored on parsing RDF and not stored in Neo4j.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">typesToLabels</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean (true)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set to true, rdf:type statements are imported as node labels in Neo4j</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">languageFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">['en','fr','es',&#8230;&#8203;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set, only literal properties with this language tag (or untagged ones) are imported</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">headerParams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">map {}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameters to be passed in the HTTP GET request or <code>payload</code> if POST request. &lt;br&gt; Example: <code>{ authorization: 'Basic user:pwd', Accept: 'application/rdf+xml'}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">commitSize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer (25000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">commit a partial transaction every n triples</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nodeCacheSize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer (10000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">keep n nodes in cache to minimize reads from DB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verifyUriSyntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean (true)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">by default, uri syntax is checked. This can be disable d by setting this parameter to <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">keepCustomDataTypes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean(false)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set to true, all properties containing a custom data type will be saved as a string followed by their custom data type IRIs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">customDataTypedPropList</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list of strings ([])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">when set, only custom data types of literal properties in this list are imported</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_ontology_import_params"><a class="link" href="#_ontology_import_params">Ontology Import Params</a></h5>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Param</th>
<th class="tableblock halign-left valign-top">values(default)</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">predicateExclusionList</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list of strings ([])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List  of predicates (full uri) that are to be ignored on parsing RDF and not stored in Neo4j.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">headerParams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">map {}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameters to be passed in the HTTP GET request or <code>payload</code> if POST request. &lt;br&gt; Example: <code>{ authorization: 'Basic user:pwd', Accept: 'application/rdf+xml'}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">commitSize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer (25000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">commit a partial transaction every n triples</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nodeCacheSize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer (10000)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">keep n nodes in cache to minimize reads from DB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">verifyUriSyntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean (true)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">by default, uri syntax is checked. This can be disable d by setting this parameter to <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classLabelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('Class')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Label for classes in the ontology</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">subClassOfRelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('SCO')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relationship name for <code>rdfs:subClassOf</code> statements</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dataTypePropertyLabelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('Property')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Label for DataTypeProperty definitions (attributes)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">objectPropertyLabelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('Relationship')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Label for ObjectProperty definitions (relationships)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">subPropertyOfRelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('SPO')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relationship  for <code>rdfs:subPropertyOf</code> statements</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">domainRelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('DOMAIN')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Domain relationship between Classes and DataTypeProperty/ObjectProperty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rangeRelName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string ('RANGE')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Range relationship between Classes and DataTypeProperty/ObjectProperty</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rdf_import_utils"><a class="link" href="#_rdf_import_utils">RDF Import Utils</a></h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Procedure Name</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description and example usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.addNamespacePrefix</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>prefix: string (like <code>owl</code>)</p>
</li>
<li>
<p>namespace: namespace part of a uri (like <code><a href="http://www.w3.org/2002/07/owl#" class="bare">http://www.w3.org/2002/07/owl#</a></code>)</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds namespace - prefix pair definition to be used for RDF import</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.listNamespacePrefixes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">params</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lists all currently defined namespace prefix definitions</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_model_mapping"><a class="link" href="#_model_mapping">Model Mapping</a></h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Procedure Name</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description and example usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.addSchema</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the schema/vocabulary/ontology</p>
</li>
<li>
<p>prefix to be used in serialisations</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a reference to a vocabulary. Needed to define mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.dropSchema</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the schema/vocabulary/ontology</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deletes a vocabulary reference and all associated mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.listSchemas</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>optional filter string</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns all vocabulary references. When filter string is set, only schemas containing the search string in their uri or in the associated prefix are returned.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.addCommonSchemas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no prams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates references to a number of popular vocabularies including schema.org, Dublin Core, SKOS, OWL, etc</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.addMappingToSchema</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>URL of the schema/voc/ontology</p>
</li>
<li>
<p>The name of the element in the Neo4j graph (a property name, a label or a relationship type)</p>
</li>
<li>
<p>The matching element (Class, DataTypeProperty or ObjectProperty) in the public schema. Only the local name of the element</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a mapping for an element in the Neo4j DB schema to a vocabulary element</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.dropMapping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">* mapped DB element name to remove the mapping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns an output text message indicating success/failure of the deletion</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.mapping.listMappings</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>optional filter string</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a list with all the currently defined mappings. Whe filter string is passed, only mappings containing the string in the
DB element name or the schema element URI are returned</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_inferencing"><a class="link" href="#_inferencing">Inferencing</a></h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stored Proc Name</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.inference.nodesLabelled</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>a string with a label name</p>
</li>
<li>
<p>parameters as described in table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns all nodes with label 'label' or its sublabels</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.inference.nodesInCategory</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>a node representing the category</p>
</li>
<li>
<p>parameters as described in table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns all nodes connected to Node 'catNode' or its subcategories</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.inference.getRels</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>a start node</p>
</li>
<li>
<p>a (real or 'virtual') relationship type</p>
</li>
<li>
<p>parameters as described in table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns all relationships of type 'virtRel' or its subtypes along with the target nodes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.inference.hasLabel <strong>(function)</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>a node</p>
</li>
<li>
<p>a label name as a string</p>
</li>
<li>
<p>parameters as described in table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">checks whether node is explicitly or implicitly labeled as 'label'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.inference.inCategory <strong>(function)</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>a node representing an instance</p>
</li>
<li>
<p>a node representing a category</p>
</li>
<li>
<p>parameters as described in table below</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">checks whether node is explicitly or implicitly in a category</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_utility_functions"><a class="link" href="#_utility_functions">Utility Functions</a></h3>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Name</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.getIRILocalName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the local part of the URI (stripping out the namespace)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.getIRINamespace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the namespace part of the URI (stripping out the local part)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.getDataType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string (a property value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the XMLSchema (or custom) datatype of a property value when present</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.getLangValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string (a property value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the value with the language tag passed as first argument or null if there&#8217;s not a value for the provided language tag</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.getValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string (a property value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the value of a datatype of a property after stripping out the datatype information or language tag  when present</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.shortFromUri</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string (a URI)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the shortened version of an IRI using the existing namespace definitions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.uriFromShort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string (a shortened URI)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the expanded (full) URI given a shortened one created in the load process with <code>n10s.importRDF</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n10s.importJSONAsTree</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>node to link the imported json to</p>
</li>
<li>
<p>the json fragment</p>
</li>
<li>
<p>(optional) relationship name linking the root node of the JSON to the node passed as first param</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Imports a JSON payload by mapping it to nodes and relationships (JSON-LD style). Requires a uniqueness constraint on :Resource(uri)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_extensions_http_endpoints"><a class="link" href="#_extensions_http_endpoints">Extensions (HTTP endpoints)</a></h3>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 15%;">
<col style="width: 5%;">
<col style="width: 45%;">
<col style="width: 35%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">method</th>
<th class="tableblock halign-left valign-top">type</th>
<th class="tableblock halign-left valign-top">params</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/describe/id/&lt;nodeid&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>nodeid: path parameter containing the id of a node</p>
</li>
<li>
<p>excludeContext: Optional named parameter. If present output will not include connected nodes, just selected one.</p>
</li>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Produces an RDF serialization of the selected node. The format will be determined by the <strong>accept</strong> parameter in the header. Default is Turtle</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/describe/uri/&lt;nodeuri&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>nodeuri: path parameter containing the (urlencoded) uri of a node.</p>
</li>
<li>
<p>excludeContext: (optional) if present output will not include connected nodes, just selected one.</p>
</li>
<li>
<p>graphuri: (optional) if present and the graph includes Quad information, only statements in the selected named graph are returned.The value  of the parameter is the (urlencoded) uri of a named graph.</p>
</li>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Produces an RDF serialization of the selected node. It works on a model either imported from an RDF dataset
via <strong>n10s.importRDF</strong>, <strong>n10s.importQuadRDF</strong> or built in a way that nodes are labeled as :Resource and have an uri.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/describe/find/&lt;l&gt;/&lt;p&gt;/&lt;v&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>the method takes three parameters passed as path parameters in the URL: &lt;l&gt;/&lt;p&gt;/&lt;v&gt;. They represent respectively a label, a property name and a property value.</p>
</li>
<li>
<p>excludeContext: Optional named parameter. If present output will not include connected nodes, just selected one.</p>
</li>
<li>
<p>valType: required when the property value is not to be treated as a string. Valid values: INTEGER, FLOAT and BOOLEAN</p>
</li>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns  nodes matching the filter on label and property value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/cypher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>POST request taking as parameter a JSON map with the following keys:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>cypher: the cypher query to run</p>
</li>
<li>
<p>cypherParams: parameters  for the cypher query</p>
</li>
<li>
<p>showOnlyMapped: (optional, default is false) if present output will exclude unmapped elements (see how to define mappings for labels,attributes, relationships)</p>
</li>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Produces an RDF serialization of the nodes and relationships returned by the Cypher query</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/cypheronrdf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>same parameters as <code>/rdf/cypher</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Same as <code>/rdf/cypher</code> but it works on a model either imported from an RDF dataset via <strong>n10s.importRDF</strong> or built in a
way that nodes are labeled as :Resource and have an uri.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/onto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">returns an OWL ontology based on the graph schema</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/rdf/ontonrdf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>
<p>format: RDF serialisation format. When present, it overrides the header param <strong>accept</strong>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Same as  /rdf/onto but it works on a model either imported from an RDF dataset via <strong>n10s.importRDF</strong> or built in a
way that nodes are labeled as :Resource and have an uri.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Examples"><a class="link" href="#Examples">Projects using NSMNTX</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://medium.com/@nick.p.doyle">Nick Doyle</a> writes on using Neo4j to map your AWS Infrastructure and he uses NSMNTX to ingest the RDF produced by <a href="http://awless.io/">awless</a>. Read his post <a href="https://medium.com/@nick.p.doyle/using-neo4j-graph-database-to-map-your-aws-infrastructure-a81b1a49981b">here</a></p>
</li>
<li>
<p>Refinitiv in their <a href="https://developers.refinitiv.com/knowledge-graph/knowledge-graph-feed-api/learning?content=48179&amp;type=learning_material_item">developers tutorials section</a> include a step by step description of how to import one of their public datasets into Neo4j using NSMNTX.</p>
</li>
<li>
<p>Tony Hammond created an Elixir wrapper library for NSMNTX. He describes it in <a href="https://medium.com/@tonyhammond/graph-to-graph-with-elixir-9cd7fd6f2128">this blog post</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We know there are more out there! If you&#8217;re using NSMNTX we&#8217;d love to hear about what you&#8217;re doing. Let us know about it at <a href="https://community.neo4j.com/">the community forum</a>.You can help us growing this list!</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-08-17 02:24:27 BST
</div>
</div>
</body>
</html>